<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>操作系统知识点总结 | 小扶苏</title><meta name="keywords" content="操作系统"><meta name="author" content="小吴顶呱呱,3118732544@qq.com"><meta name="copyright" content="小吴顶呱呱"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="操作系统知识点总结"><meta name="application-name" content="操作系统知识点总结"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="操作系统知识点总结"><meta property="og:url" content="https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html"><meta property="og:site_name" content="小扶苏"><meta property="og:description" content="一、操作系统概述 1.1 操作系统的定义与目标 定义：操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。 目标：方便性，有效性（提高系统资源的利用率、提高系统的吞吐量），可扩充性，开放性。 1.2 操作系统的基本功能 1.统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://xiaofusu.github.io/img/aust3.jpg"><meta property="article:author" content="小吴顶呱呱"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaofusu.github.io/img/aust3.jpg"><meta name="description" content="一、操作系统概述 1.1 操作系统的定义与目标 定义：操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。 目标：方便性，有效性（提高系统资源的利用率、提高系统的吞吐量），可扩充性，开放性。 1.2 操作系统的基本功能 1.统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?642f3736fd0dc1840cc19eba1cc8c173";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://xiaofusu-twikoo.hf.space',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 爱敲代码小废物","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 追求自由与安逸","🤝 撞了南墙不回头","🏃 脚踏实地行动派","🧱 团队小组发动机"]},
  algolia: {"appId":"KLSR2EJ8T1","apiKey":"37a50f959e0a2676ea91700f95524c57","indexName":"hexo_blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小吴顶呱呱","link":"链接: ","source":"来源: 小扶苏","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小扶苏',
  title: '操作系统知识点总结',
  postAI: '',
  pageFillDescription: '一、操作系统概述, 1.1 操作系统的定义与目标, 1.2 操作系统的基本功能, 1.3 操作系统的特征（重点）, 1.4操作系统的中断处理, 1.5操作系统的发展与分类（重点）, 1.6操作系统的主要功能（重点）, 二、进程管理, 2.1进程的定义, 2.2进程的五个特性, 2.3进程的基本状态与转换（重点）, 2.3.1 进程的三种基本状态, 2.3.2 五状态转换模型, 2.3.3 挂起操作和进程状态的转换, 2.4 进程控制块PCB, 2.4.1 PCB的定义, 2.4.2 PCB的作用, 2.4.3 PCB中的信息, 2.5 线程与进程的比较, 三、处理机调度与死锁, 3.1 处理机调度的层次和调度算法的目标, 3.2 作业与作业调度（重点）, 3.2.1 先来先服务调度算法（FCFS), 3.2.2 短作业优先调度算法(SJF), 3.2.3 高优先权优先调度算法(HRRN), 3.2.4 基于时间片的轮转调度算法(RR), 3.2.5 多级反馈队列调度算法, 3.3 实时调度（重点）, 3.3.1 最早截止时间优先算法, 3.3.2 最低松弛度优先算法, 3.4 死锁概述, 3.5 银行家算法（重点）, 四、进程同步, 4.1 进程同步概念, 4.2 信号量机制（重点）, 4.2.1 整型信号量（了解即可）, 4.2.2 记录型信号量（重要）, 4.2.3 AND型信号量, 4.3 信号量的应用, 4.4 经典进程的同步问题, 4.4.1 生产者-消费者问题, 4.4.2 哲学家进餐问题, 4.4.3 读者-写者问题, 五、存储器管理, 5.1存储器的层次结构, 5.2 程序的装入和链接, 5.2.1 三种装入方式, 5.2.2 程序的链接, 5.3 连续分配方式, 5.3.1 单一连续分配, 5.3.2 固定分区分配, 5.3.3 动态分区分配（重点）, 5.4 对换, 5.5 分页存储管理方式（重点）, 5.5.1 什么是分页存储, 5.5.2 页表, 5.5.3 逻辑地址结构, 5.5.4 基本地址变换机构（重点）, 5.5.5 具有快表的地址变换机构, 5.6 分段存储管理方式, 5.6.1 分段存储管理方式的引入, 5.6.2 分段系统的基本原理, 5.6.3 段表, 5.6.4 地址变换机构, 5.7 分段和分页的主要区别（重点）, 六、虚拟存储器, 6.1 虚拟存储器的定义和特征（重要）, 6.2 请求分页存储管理方式, 6.3 页面置换算法（重要）, 6.3.1 最佳置换算法（OPT）, 6.3.2 先进先出置换算法（FIFO）, 6.3.3 最近最久未使用置换算法（LRU）, 6.3.4 时钟置换算法（CLOCK）, 6.3.5 各算法总结, 七、输入输出系统, 7.1 I/O系统的层次结构和模型, 7.2 I/O设备和设备控制器, 7.2.1 I/O设备的分类, 7.2.2 设备与控制器之间的接口, 7.2.3 设备控制器, 7.3 中断机构和中断处理程序, 7.3.1 中断简介, 7.3.2 中断处理, 7.4 I/O控制方式, 7.4.1 程序I/O方式, 7.4.2 中断驱动I/O控制方式, 7.4.3 直接存储器访问(DMA)I/O控制方式, 7.4.4  I/O通道控制方式, 四种控制方式的总结与比较, 7.5 设备分配, 7.5.1 设备分配中数据结构, 7.5.2 分配设备, 7.6 磁盘调度算法, 7.6.1 先来先服务（FCFS）, 7.6.2 最短寻道时间优先(SSTF）, 7.6.3 基于扫描的磁盘调度算法一操作系统概述操作系统的定义与目标定义操作系统是控制管理计算机系统的硬软件分配调度资源的系统软件目标方便性有效性提高系统资源的利用率提高系统的吞吐量可扩充性开放性操作系统的基本功能统一管理计算机资源处理器资源设备资源存储器资源文件资源实现了对计算机资源的抽象设备管理软件提供读写接口文件管理软件提供操作文件接口提供了用户与计算机之间的接口图形用户界面命令形式系统调用形式操作系统的特征重点最基本的特征互为存在条件并发共享并发并行俩个或多个时间可以在同一个时刻发生多核可以实现并行并发同一个时间间隔发生每个程序交替执行共享性操作系统中的资源可以供多个并发的程序共同使用称为资源共享互斥共享当资源被资源占用时其他想使用的程序只能等待同时访问某种资源并发的被多个程序访问虚拟和异步性的前提是具有并发性虚拟性表现为把一个物理实体转变为若干个逻辑实体时分复用技术资源在时间上进行复用不同程序并发使用多到程序使用计算机的硬件资源提高资源的利用率空分复用技术用来实现虚拟磁盘物理磁盘虚拟为逻辑磁盘电脑上的盘盘等虚拟内存在逻辑上扩大程序的存储容量等提高资源的利用率提高编程效率异步性在多道程序环境下允许多个进程并发执行但由于资源等因素的限制使进程的执行以停停走走的方式运行而且每个进程执行的情况运行暂停速度完成也是未知的操作系统的中断处理中断机制的作用为了在多道批处理系统中让用户进行交互中断的产生发生中断时立马切换到管态开展管理工作管态又叫特权态系统态或者核心态是操作系统管理的程序执行时机器所处的状态发生中断后当前运行的进程会暂停运行由操作系统内核对中断进行处理对于不同的中断信号会进行不同的处理中断的分类内中断也叫异常例外陷入信号来源内部与当前执行指令有关外中断中断信号来源外部与当前执行指令无关操作系统的发展与分类重点手工操作阶段用户独占全机人机速度矛盾导致资源利用率极低单道批处理引入脱机输入输出技术用外围机磁带完成并由监督程序负责控制作业的输入输出主要优点缓解了一定程度的人机速度矛盾资源利用率有所提升缺点内存中仅仅能有一道程序运行只有该程序运行结束之后才能调入下一道程序有大量的时间是在空闲等待完成资源利用率依然很低多道批处理主要优点多道程序并发执行共享计算机资源资源利用率大幅提升和其他资源更能保持忙碌状态系统吞吐量增大缺点用户相应时间长没有人机交互功能用户提交自己的作业之后只能等待计算机处理完成中间不能控制自己的作业执行比如无法调试程序无法在程序运行过程中输入一些参数分时操作系统计算机以时间片为单位轮流为各个用户作业服务各个用户可以通过终端与计算机进行交互主要优点用户请求可以被及时响应解决了人机交互问题允许多个用户同时使用一台计算机并且用户对计算机的操作相互独立感受不到别人的存在主要缺点不能优先处理一些紧急任务操作系统对各个用户作业都是完全公平的循环的为每个用户作业服务一个时间片不区分任务的紧急性实时操作系统在实时操作系统的控制下计算机系统接收到外部信号后及时进行处理并且严格的时限内处理完事件实时操作系统的主要特点是及时性和可靠性主要优点能够响应一些紧急的任务某些紧急任务不需要时间片排队操作系统的主要功能重点处理机管理功能存储器管理功能设备管理功能文件管理功能接口管理功能二进程管理进程的定义为什么需要进程进程是系统进行资源分配和调度的基本单位进程作为程序独立运行的载体保障程序正常执行进程的存在使得操作系统资源的利用率大幅提升什么是进程进程是程序的执行过程是系统进行资源分配和调度的一个独立单位进程控制块用于描述和控制进程运行的通用数据结构记录进程当前状态和控制进程运行的全部信息是进程存在的唯一标识进程与线程线程操作系统进行运行调度的最小单位进程系统进行资源分配和调度的基本单位区别与联系一个进程可以有一个或多个线程线程包含在进程之中是进程中实际运行工作的单位进程的线程共享进程资源一个进程可以并发多个线程每个线程执行不同的任务进程的五个特性动态性进程具有生命周期它由系统创建而诞生被调度而执行因得不到资源而暂停最后因被撤销而消亡并发性不同进程的动作在时间上可以重叠即系统内的多个进程是可以并发执行的独立性进程实体是一个能独立运行的基本单位同时也是系统中独立获得资源和独立调动的基本单位在今天既有进程又有线程的操作系统中进程是一个能独立运行的基本单位但不再是一个可执行的实体系统独立运行的基本单位变成线程了异步性进程按各自独立的不可预知的速度向前推进不可预知的原因是并发执行结构特性从结构上看每个进程都由程序段数据段和一个三部分组成进程的基本状态与转换重点进程的三种基本状态就绪状态当进程已分配到除外的所有需要的资源只要再获得处理机的资源便可以立即执行执行状态当进程已获得处理机资源其资源正在处理机上执行阻塞状态正在执行的进程由于等待某个事件发生而无法执行时便放弃处理机资源而处于阻塞状态五状态转换模型在不少系统中增加了两种基本状态新状态进程刚被创建并分配资源时终止状态在进程结束后不会立即撤销进程相应的进程会暂时留在系统中以便收集进程的相关信息挂起操作和进程状态的转换在许多系统中为了满足系统和用户观察与分析进程的需要加入挂起这一重要操作引入挂起的目的终端用户的需要父进程的需要负荷调节的需要的需要状态转换活动就绪禁止就绪活动阻塞禁止就绪禁止就绪活动就绪禁止阻塞活动阻塞进程控制块的定义是系统为了描述和控制进程的运行而为进程定义的一种数据结构是进程实体的一部分是进程存在的唯一标志也是操作系统中最重要的结构体类型的数据结构中存放着操作系统所需要的用于描述进程当前情况以及控制进程运行的全部信息的作用作为独立运行基本单位的标志实现间断性运行方式提供进程管理所需的信息提供进程调度所需要的信息实现与其他进程的同步和通信中的信息进程标识符系统内用于标识一个进程的唯一编号处理机状态进程调度信息进程控制信息线程与进程的比较从调度的基本单位并发性拥有资源等方面对线程和进程进行比较调度的基本单位在传统中进程作为独立调度和分派的基本单位能够独立运行其在每次被调度时候都需要进行上下文切换开销较大而在引入线程的中已经把线程作为调度和分派的基本单位因而线程是能够独立运行的基本单位在同一个进程中线程的切换不会引起进程的切换但进程的切换必然引起线程的切换并发性不同的进程之间可以并发执行而且在一个进程中的多个线程也可以并发执行还允许一个进程中的所有线程可以并发执行不同进程中的线程也可以并发执行拥有资源进程可以拥有资源并可以作为系统中拥有资源的一个基本单位然而线程几乎不拥有资源独立性在同一个进程中的不同线程之间的独立性要比不同进程之间的独立性差很多系统开销创建进程的系统开销远大于创建线程支持多处理机系统对于传统进程即单线程进程不管有多少处理机该进程只能运行在一个处理机上但对于多线程进程可以将一个进程中的多个线程分配到多个处理机上并行运行加快进程的完成三处理机调度与死锁处理机调度的层次和调度算法的目标高级调度作业调度几个作业调入内存为它们创建进程分配必要的资源外存内存低级调度进程调度调度的对象是进程或者内核级线程内存处理机中级调度内存调度暂时不能运行的进程调至外存等待外存内存处理机调度算法的共同目标资源利用率主要是利用率公平性获得合理的时间平衡性进程类型计算型输入输出型策略强制执行系统的安全策略批处理系统的目标平均周转时间系统吞吐量处理机利用率分时系统的目标响应速度快均衡性实时系统的目标截止时间可预测性作业与作业调度重点作业作业是一个比程序更为广泛的概念他不仅包含了通常的程序和数据而且还应配有一份作业说明书系统根据该说明书来对程序的运行进行控制在批处理系统中是以作业为基本单位从外存调入内存作业调度的主要任务根据作业控制块中的信息审查系统能否满足用户作业的资源需求以及按照一定的算法从外存的后背队列中选取某些作业调入内存并为它们创建进程分配必要的资源然后再将新创建的进程插入就绪队列准备执行先来先服务调度算法该算法既可用于作业调度也可用于进程调度非抢占式该算法每次调度都是从后背作业中选择一个或者多个最先进入该队列的作业将它们调入内存为它们分配资源创建进程然后放入就绪队列先来先服务算法比较有利于长作业进程而不利于短作业进程短作业优先调度算法为了追求最少的平均等待时间最少的平均周转时间最少的平均带权周转时间每次调度时选择当前已到达且最短的作业进程优先的到服务所谓的最短也就是服务时间最短即可用于作业调度也可用于进程调度采用短作业优先不论是平均周转时间还是平均带权周转时间都有明显的改善所以短作业优先可以有效降低作业的平均等待时间提高系统吞吐量缺点该算法对长作业不利可能产生长作业饥饿未考虑作业的紧迫程度因此不能保证紧迫性作业程序会被及时处理由于作业进程的长短只是根据用户所提供的的估计执行时间定的而用户有可能会有意或无意缩短其作业的估计运行时间致使该算法不一定能做到短作业优先调度高优先权优先调度算法当把该算法用于作业调度时系统将从后备队列中选择若干个优先权最高的作业装入内存当用于进程调度时该算法是把处理机分配给就绪队列中优先权最高的进程这时又可进一步把该算法分成如下两种非抢占式优先权算法系统一旦吧处理机分配给就绪队列中优先权最高的进程后该进程就会一直执行下去直至完成抢占式优先权调度算法在这种方式下系统同样是把处理机分配给优先权最高的进程使之执行但在其执行期间只要又出现了另一个其优先权更高的进程进程调度程序就立即停止当前进程原优先权最高的进程的执行重新将处理机分配给新到的优先权最高的进程这种抢占式的更好地满足紧迫作业的要求确定进程优先权的依据进程类型通常系统进程如接收进程对换进程磁盘进程的优先权高于一般用户进程的优先权进程对资源的需求如进程的估计执行时间及内存需要量的多少对这些要求少的进程应赋予较高的优先权用户要求这是由用户进程的紧迫程度及用户所付费用的多少来确定优先权的高响应比优先调度算法在每次调度时先计算各个作业进程的响应比选择响应比最高的作业进程为其服务由上式可以看出如果作业的等待时间相同则要求服务的时间愈短其优先权愈高因而该算法有利于短作业当要求服务的时间相同时作业的优先权决定于其等待时间等待时间愈长其优先权愈高因而它实现的是先来先服务对于长作业作业的优先级可以随等待时间的增加而提高当其等待时间足够长时其优先级便可升到很高从而也可获得处理机简言之该算法既照顾了短作业又考虑了作业到达的先后次序不会使长作业长期得不到服务因此该算法实现了一种较好的折衷当然在利用该算法时每要进行调度之前都须先做响应比的计算这会增加系统开销基于时间片的轮转调度算法算法思想公平地轮流地为各个进程服务让每个进程在一定时间间隔内都可以得到相应原理按照各进程到达就绪队列的顺序轮流让各个进程执行一个时间片如若进程未在一个时间片内执行完则剥夺处理机将进程重新放到就绪队列队尾重新排队只用于进程调度只有当作业放入内存建立了相应的进程后才能被分配处理机时间片抢占式多级反馈队列调度算法应设置多个就绪队列并为各个队列赋予不同的优先级第一个队列的优先级最高第二个队列次之其余各队列的优先权逐个降低该算法赋予各个队列中进程执行时间片的大小也各不相同在优先权愈高的队列中为每个进程所规定的执行时间片就愈小当一个新进程进入内存后首先将它放入第一队列的末尾按原则排队等待调度当轮到该进程执行时如它能在该时间片内完成便可准备撤离系统如果它在一个时间片结束时尚未完成调度程序便将该进程转入第二队列的末尾再同样地按原则等待调度执行如果它在第二队列中运行一个时间片后仍未完成再依次将它放入第三队列如此下去当一个长作业进程从第一队列依次降到第队列后在第队列中便采取按时间片轮转的方式运行按队列优先级调度仅当第一队列空闲时调度程序才调度第二队列中的进程运行仅当第队列均空时才会调度第队列中的进程运行如果处理机正在第队列中为某进程服务时又有新进程进入优先权较高的队列第中的任何一个队列则此时新进程将抢占正在运行进程的处理机即由调度程序把正在运行的进程放回到第队列的末尾把处理机分配给新到的高优先权进程实时调度重点实现实时调度的基本条件提供必要的信息就绪时间开始时间和截止时间处理时间资源要求优先级系统处理能力强最早截止时间优先算法该算法是根据任务的开始截止时间来确定任务的优先级截止时间越早其优先级越高该算法要求在系统中保持一个实时任务就绪队列该队列按各任务截止时间的早晚排序具有最早截止时间的任务排在队列的最前面调度程序在选择任务时总是选择就绪队列的第一个任务即可用于抢占式调度也可用于非抢占式调度非抢占式调度方式用于非周期实时任务如下图所示将该算法用于非抢占调度方式之例该例中具有四个非周期任务它们先后到达系统首先调度任务执行在任务执行期间任务又先后到达由于任务的开始截止时间早于任务故系统在任务后将调度任务执行在此期间又到达作业其开始截止时间仍是早于任务的故在任务执行完后系统又调度任务执行最后才调度任务执行抢占式调度方式用于周期实时任务为了说明通常的优先级调度不能适用于实时系统该图特增加了第二和第三行在第二行中假定任务具有较高的优先级所以在时先调度执行在完成后才调度执行在时调度执行在时完成又调度执行在时调度执行在时虽然已完成但已错过了它的最后期限这说明了利用通常的优先级调度已经失败第三行与第二行类似只是假定任务具有较高的优先级最低松弛度优先算法该算法是根据任务紧急的程度来确定任务的优先级任务的紧急程度越高为该任务所赋予的优先级就越高使之优先执行该算法主要用于抢占式调度方式假如在一个实时系统中有两个周期性实时任务和任务要求每执行一次执行时间为任务只要求每执行一次执行时间为由此可得知任务和每次必须完成的时间分别为和见图为保证不遗漏任何一次截止时间应采用最低松弛度优先的抢占调度策略在刚开始时必须在时完成而它本身运行又需可算出的松弛度为必须在时完成而它本身运行就需可算出的松弛度为故调度程序应先调度执行在时的松弛度可按下式算出的松弛度必须完成时间其本身的运行时间当前时间类似地可算出的松弛度为故调度程序应选择运行在时的松弛度已减为即而的松弛度为即于是调度程序应抢占的处理机而调度运行在时的松弛度为即而的松弛度仅为即故又应重新调度执行在时执行完成而此时的松弛度已减为即而的松弛度为即于是又应调度执行在时任务尚未进入第周期而任务已进入第周期故再调度执行在时的松弛度已减至即而的松弛度为即故此时调度又应抢占的处理机而调度执行图示出了具有两个周期性实时任务的调度情况死锁概述产生死锁的原因竞争资源进程间推进顺序非法进程在运行过程中请求和释放资源的顺序不当产生死锁的必要条件互斥条件请求和保持条件不剥夺条件环路等待条件处理死锁的基本方法预防死锁去破坏产生死锁的四个必要条件中的一个或者几个条件避免死锁在资源的动态分配过程中用某种方法去防止系统进入不安全状态检测死锁允许系统发生死锁然后检测出死锁的发生并精确确定与死锁有关的进程和资源采取措施将死锁清除掉解除死锁撤销或挂起一些进程以便回收一些资源再将这些资源分配给已处于阻塞状态的进程使之转为就绪状态预防死锁的方法破坏请求和保持条件所有进程在开始运行之前都必须一次性申请所需的全部资源优点简单易于实现且安全缺点资源严重浪费进程延迟运行破坏不可抢占条件一个进程申请其他资源而不能满足时必须释放已有资源破坏环路等待条件所有资源按类型进行线性排队严格依次分配资源银行家算法重点文字太枯燥并且看不明白去看个视频秒懂四进程同步进程同步概念俩种形式的制约关系在多道程序环境下当程序并发执行时由于资源共享和进程合作使同处于一个系统中的诸进程之间可能存在着俩种形式的制约关系间接相互制约关系同处于一个系统中的进程通常都共享着某种系统资源如共享共享设备等所谓间接相互制约即源于这种资源共享例如有两个进程和如果在进程提出打印请求时系统已将惟一的一台打印机分配给了进程则此时进程只能阻塞一旦进程将打印机释放则进程才能由阻塞改为就绪状态直接相互制约关系这种制约主要源于进程间的合作例如有一输入进程通过单缓冲向进程提供数据当该缓冲空时计算进程因不能获得所需数据而阻塞而当进程数据输入输入缓冲区后便将进程唤醒反之当缓冲区已满时进程因不能再向缓冲区投放数据而阻塞当进程将缓冲区数据取走后便可唤醒临界区不论是硬件临界资源还是软件临界资源多个进程必须互斥地对它进行访问人们把在每个进程中访问临界资源的那段代码称为临界区显然若能保证诸进程互斥地进入自己的临界区便可实现诸进程对临界资源的互斥访问为此每个进程在进入临界区之前应先对欲访问的临界资源进行检查看它是否正被访问如果此刻该临界资源未被访问进程便可进入临界区对该资源进行访问并设置它正被访问的标志如果此刻该临界资源正被某进程访问则本进程不能进入临界区因此必须在临界区前面增加一段用于进行上述检查的代码把这段代码称为进入区相应地在临界区后面也要加上一段称为退出区的代码用于将临界区正被访问的标志恢复为未被访问的标志信号量机制重点整型信号量了解即可最初由把整型信号量定义为一个用于表示资源数目的整型量它与一般整型量不同除初始化外仅能通过两个标准的原子操作和来访问很长时间以来这两个操作一直被分别称为操作和是两个原子操作因此它们在执行时是不可中断的亦即当一个进程在修改某信号量时没有其他进程可同时对该信号量进行修改此外在操作中对值的测试和做操作时都不可中断记录型信号量重要在整型信号量机制中的操作只要是信号量就会不断地测试因此该机制并未遵循让权等待的准则而是使进程处于忙等的状态记录型信号量机制则是一种不存在忙等现象的进程同步机制用记录型数据结构表表示的信号量相应地和操作可描述为在记录型信号量机制中的初值表示系统中某类资源的数目因而又称为资源信号量对它的每次操作意味着进程请求一个单位的该类资源使系统中可供分配的该类资源数减少一个因此描述为当时表示该类资源已分配完毕因此进程应调用原语进行自我阻塞放弃处理机并插入到信号量链表中可见该机制遵循了让权等待准则此时的绝对值表示在该信号量链表中已阻塞进程的数目对信号量的每次操作表示执行进程释放一个单位资源使系统中可供分配的该类资源数增加一个故操作表示资源数目加若加后仍是则表示在该信号量链表中仍有等待该资源的进程被阻塞故还应调用原语将链表中的第一个等待进程唤醒如果的初值为表示只允许一个进程访问临界资源此时的信号量转化为互斥信号量用于进程互斥型信号量同步机制的基本思想是将进程在整个运行过程中需要的所有资源一次性全部地分配给进程待进程使用完后再一起释放只要尚有一个资源未能分配给进程其它所有可能为之分配的资源也不分配给它亦即对若干个临界资源的分配采取原子操作方式要么把它所请求的资源全部分配到进程要么一个也不分配由死锁理论可知这样就可避免上述死锁情况的发生为此在操作中增加了一个条件故称为同步或称为同时操作即定义如下信号量的应用利用信号量实现进程互斥为了使多个进程能够互斥地访问某个临界资源只需为该资源设置一个互斥信号量并设其初始值为然后将各进程访问该资源的临界区置于和操作之间即可每个欲访问该临界资源的进程在进入临界区之前都要先对执行操作若该资源此刻未被访问本次操作必然成功进程便可进入自己的临界区这时若再有其他进程也欲进入自己的临界区此时由于对执行操作定会失败因而该进程阻塞从而保证了该临界资源能被互斥地访问当访问临界资源的进程退出临界区后又应对执行操作以便释放该临界资源利用信号量实现进程互斥的进程可描述如下利用信号量实现前驱关系如图利用信号量实现此前驱图注控制变量可以根据有向边或节点数目定义节点入度为进程可执行经典进程的同步问题生产者消费者问题假定在生产者和消费者之间的公用缓冲池中具有个缓冲区这时可利用互斥信号量实现诸进程对缓冲池的互斥使用利用信号量和分别表示缓冲池中空缓冲区和满缓冲区的数量又假定这些生产者和消费者相互等效只要缓冲池未满生产者便可将消息送入缓冲池只要缓冲池未空消费者便可从缓冲池中取走一个消息对生产者消费者问题可描述如下生产者申请空闲缓冲区申请互斥信号量释放互斥信号量释放满缓冲区消费者申请满缓冲区申请互斥信号量释放互斥信号量释放空闲缓冲区在生产者消费者问题中应注意首先在每个程序中用于实现互斥的和必须成对地出现其次对资源信号量和的和操作同样需要成对地出现但它们分别处于不同的程序中例如在计算进程中而则在消费进程中计算进程若因执行而阻塞则以后将由消费进程将它唤醒最后在每个程序中的多个操作顺序不能颠倒应先执行对资源信号量的操作然后再执行对互斥信号量的操作否则可能引起进程死锁哲学家进餐问题放在桌子上的筷子是临界资源在一段时间内只允许一位哲学家使用为了实现对筷子的互斥使用可以用一个信号量表示一只筷子由这五个信号量构成信号量数组其描述如下在以上描述中当哲学家饥饿时总是先去拿他左边的筷子即执行成功后再去拿他右边的筷子即执行又成功后便可进餐进餐完毕又先放下他左边的筷子然后再放右边的筷子虽然上述解法可保证不会有两个相邻的哲学家同时进餐但有可能引起死锁假如五位哲学家同时饥饿而各自拿起左边的筷子时就会使五个信号量均为当他们再试图去拿右边的筷子时都将因无筷子可拿而无限期地等待对于这样的死锁问题可采取以下几种解决方法至多只允许有四位哲学家同时去拿左边的筷子最终能保证至少有一位哲学家能够进餐并在用毕时能释放出他用过的两只筷子从而使更多的哲学家能够进餐仅当哲学家的左右俩只筷子均可用时才允许他拿起筷子进餐规定偶数号哲学家先拿他左边的筷子然后再去那右边的筷子而奇数号相反按此规定将是号哲学家竞争号筷子号哲学家竞争号筷子即五位哲学家都先竞争奇数号筷子获得后再去竞争偶数号筷子最后总会有一位哲学家能获得两只筷子而进餐读者写者问题为实现与进程间在读或写时的互斥而设置了一个互斥信号量另外再设置一个整型变量表示正在读的进程数目由于只要有一个进程在读便不允许进程去写因此仅当表示尚无进程在读时进程才需要执行操作若操作成功进程便可去读相应地做操作同理仅当进程在执行了减操作后其值为时才须执行操作以便让进程写又因为是一个可被多个进程访问的临界资源因此也应该为它设置一个互斥信号量读者写者问题可描述如下请给出一个写者优先的读者写者问题的算法描述多个写进程连续写五存储器管理存储器的层次结构对于通用计算机而言存储层次至少应具有三级最高层为寄存器中间为主存最底层是辅存在较高档的计算机中还可以根据具体的功能分工细划为寄存器高速缓存主存储器磁盘缓存固定磁盘可移动存储介质等层如图所示在存储层次中越往上存储介质的访问速度越快价格也越高相对存储容量也越小其中寄存器高速缓存主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴掉电后它们存储的信息不再存在固定磁盘和可移动存储介质属于设备管理的管辖范畴它们存储的信息将被长期保存程序的装入和链接将一个用户源程序变为一个可在内存中执行的程序通常都要经过以下几个步骤首先是要编译由编译程序将用户源代码编译成若干个目标模块其次是链接由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起形成一个完整的装入模块最后是装入由装入程序将装入模块装入内存三种装入方式绝对装入方式在编译时如果知道程序将驻留在内存的什么位置那么编译程序将产生绝对地址的目标代码绝对装入程序按照装入模块中的地址将程序和数据装入内存装入模块被装入内存后由于程序中的逻辑地址与实际内存地址完全相同故不须对程序和数据的地址进行修改绝对装入方式只能将目标模块装入到内存中事先指定的位置在多道程序环境下编译程序不可能预知所编译的目标模块应放在内存的何处因此绝对装入方式只适用于单道程序环境可重定位装入方式在多道程序环境下所得到的目标模块的起始地址通常是从开始的程序中的其它地址也都是相对于起始地址计算的此时应采用可重定位装入方式根据内存的当前情况将装入模块装入到内存的适当位置可重定位装入方式可将装入模块装入到内存中任何允许的位置故可用于多道程序环境但这种方式并不允许程序运行时在内存中移动位置动态运行时装入方式因为程序在内存中的移动意味着它的物理位置发生了变化这时必须对程序和数据的地址是绝对地址进行修改后方能运行然而实际情况是在运行过程中它在内存中的位置可能经常要改变此时就应采用动态运行时装入的方式程序的链接根据链接时间的不同可把链接分成如下三种静态链接在程序运行之前先将各目标模块及它们所需的库函数链接成一个完整的装配模块以后不再拆开我们把这种事先进行链接的方式称为静态链接方式装入时动态链接这是指将用户源程序编译后所得到的一组目标模块在装入内存时采用边装入边链接的链接方式运行时动态链接这是指对某些目标模块的链接是在程序执行中需要该目标模块时才对它进行的链接连续分配方式单一连续分配这是最简单的一种存储管理方式但只能用于单用户单任务的操作系统中采用这种存储管理方式时可把内存分为系统区和用户区两部分系统区仅提供给使用通常是放在内存的低址部分用户区是指除系统区以外的全部内存空间提供给用户使用固定分区分配分区大小相等所有的内存分区大小相等其缺点是缺乏灵活性即当程序太小时会造成内存空间的浪费当程序太大时一个分区又不足以装入该程序致使该程序无法运行尽管如此这种划分方式仍被用于利用一台计算机去控制多个相同对象的场合因为这些对象所需的内存空间是大小相等的例如炉温群控系统就是利用一台计算机去控制多台相同的冶炼炉分区大小不等为了克服分区大小相等而缺乏灵活性的这个缺点可把内存区划分成含有多个较小的分区适量的中等分区及少量的大分区这样便可根据程序的大小为之分配适当的分区动态分区分配重点动态分区分配是根据进程的实际需要动态地为之分配内存空间在实现可变分区分配时将涉及到分区分配中所用的数据结构分区分配算法和分区的分配与回收操作这样三个问题分区分配中的数据结构空闲分区表在系统中设置一张空闲分区表用于记录每个空闲分区的情况每个空闲分区占一个表目表目中包括分区序号分区始址及分区的大小等数据项空闲分区链为了实现对空闲分区的分配和链接在每个分区的起始部分设置一些用于控制分区分配的信息以及用于链接各分区所用的前向指针在分区尾部则设置一后向指针通过前后向链接指针可将所有的空闲分区链接成一个双向链分区分配算法重点首次适应算法每次都从低地址开始查找找到第一个能满足大小的空闲分区空闲分区以地址递增的次序排序每次分配内存时顺序查找空闲分区链或空闲分区表找到大小能满足要求的第一个第一个空闲分区优点倾向于优先利用内存中低址部分的空闲分区从而保留了高址部分的大空闲区这给为以后到达的大作业分配大的内存空间创造了条件缺点低址部分不断被划分会留下许多难以利用的很小的空闲分区而每次查找又都是从低址部分开始这无疑会增加查找可用空闲分区时的开销循环首次适应算法由首次适应算法演变而成的在为进程分配内存空间时不再是每次都从链首开始查找而是从上次找到的空闲分区的下一个空闲分区开始查找直至找到一个能满足要求的空闲分区从中划出一块与请求大小相等的内存空间分配给作业该算法能使内存中的空闲分区分布得更均匀从而减少了查找空闲分区时的开销但这样会缺乏大的空闲分区最佳适应算法所谓最佳是指每次为作业分配内存时总是把能满足要求又是最小的空闲分区分配给作业避免大材小用空闲分区按照容量递增次序连接每次分配内存时顺序查找空闲房分区链或空闲分区表找到大小能满足的第一个空闲分区缺点每次都选最小的分区进行分配会留下越来越大很小的难以利用的内存块因此这种方法会产生很多外部碎片最坏适应算法最坏适应分配算法要扫描整个空闲分区表或链表总是挑选一个最大的空闲区分割给作业使用其优点是可使剩下的空闲区不至于太小产生碎片的几率最小对中小作业有利同时最坏适应分配算法查找效率很高该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链查找时只要看第一个分区能否满足作业要求但是该算法的缺点也是明显的它会使存储器中缺乏大的空闲分区快速适应算法又称为分类搜索法是将空闲分区根据其容量大小进行分类对于每一类具有相同容量的所有空闲分区单独设立一个空闲分区链表这样系统中存在多个空闲分区链表同时在内存中设立一张管理索引表该表的每一个表项对应了一种空闲分区类型并记录了该类型空闲分区链表表头的指针空闲分区的分类是根据进程常用的空间大小进行划分如等对于其它大小的分区如这样的空闲区既可以放在的链表中也可以放在一个特殊的空闲区链表中优点查找效率高仅需要根据进程的长度寻找到能容纳它的最小空闲区链表并取下第一块进行分配即可另外该算法在进行空闲分区分配时不会对任何分区产生分割所以能保留大的分区满足对大空间的需求也不会产生内存碎片缺点分区归还主存时算法复杂系统开销较大以空间换时间会造成空间浪费对换在多道程序的环境下一反面在内存中的某些进程由于某事件尚未发生而被阻塞运行但是它却占用大量的内存空间甚至有时可能出现在内存中所有进程都被阻塞而迫使停止下来等待的情况另一方面却又有着许多作业在外存上等待因无内存而不能进入内存运行的情况显然这对系统资源是一种严重的浪费且使得系统吞吐量下降为了解决这一问题在系统中又增设了对换也称交换设施所谓对换是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上以便腾出足够的内存空间再把已具备运行条件的进程或进程所需要的程序和数据调入内存对换是提高内存利用率的有效措施对换分为整体对换进程对换和部分对换页面对换或分段对换对换是以整个进程为单位的便称之为整体对换或进程对换被广泛地应用于分时系统中其目的是用来解决内存紧张问题并可进一步提高内存的利用率对换是以页或段为单位进行的则分别称之为页面对换或分段对换又统称为部分对换对换方法是实现后面要讲到的请求分页和请求分段式存储管理的基础其目的是为了支持虚拟存储系统为了实现进程对换系统必须能实现三方面的功能对换空间的管理进程的换出以及进程的换入对换空间的管理外存分为文件区和对换区前者用于存放文件后者用于存放从内存换出的进程由于通常的文件都是较长久地驻留在外存上故对文件区管理的主要目标是提高文件存储空间的利用率为此对文件区采取离散分配方式进程在对换区中驻留的时间是短暂的对换操作又较频繁故对对换空间管理的主要目标是提高进程换入和换出的速度为此采取的是连续分配方式较少考虑外存中的碎片问题进程的换出系统首先选择处于阻塞状态且优先级最低的进程作为换出进程然后启动磁盘将该进程的程序和数据传送到磁盘的对换区上进程的换入系统应定时地查看所有进程的状态从中找出就绪状态但已换出的进程将其中换出时间最久换出到磁盘上的进程作为换入进程将之换入分页存储管理方式重点什么是分页存储将内存空间分为一个个大小相等的分区比如每个分区每个分区就是一个页框页框页帧内存块物理块物理页面每个页框有一个编号即页框号页框号页帧号内存块号物理块号物理页号页框号从开始将进程的逻辑地址空间也分为与页框大小相等的一个个部分每个部分称为一个页或页面每个页面也有一个编号即页号页号也是从开始操作系统以页框为单位为各个进程分配内存空间进程的每个页面分别放入一个页框中也就是说进程的页面与内存的页框有一一对应的关系各个页面不必连续存放可以放到不相邻的各个页框中页表为了能知道进程的每个页面在内存中存放的位置操作系统要为每个进程建立一张页表页表通常存在进程控制块中一个进程对应一张页表进程的每个页面对应一个页表项每个页表项由页号和块号组成页表记录进程页面和实际存放的内存块之间的映射关系每个页表项占多少字节而页号是不占用字节的如何实现地址的转换如果要访问逻辑地址则确定逻辑地址对应的页号找到号页面在内存中的起始地址需要查页表确定逻辑地址的页内偏移量逻辑地址对应的物理地址号页面在内存中的起始地址页内偏移量页号逻辑地址页面长度取除法的整数部分页内偏移量逻辑地址页面长度取除法的余数部分逻辑地址结构分页存储管理的逻辑地址结构如下所示基本地址变换机构重点基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址通常会在系统中设置一个页表寄存器存放页表在内存中的起始地址和页表长度进程未执行时页表的起始地址额页表长度存放在进程控制块中当进程被调度时操作系统内核会把他们放到页表寄存器中具有快表的地址变换机构为了提高地址变换速度可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器又称为联想寄存器或称为快表地址变换过程是在给出有效地址后由地址变换机构自动地将页号送入高速缓冲寄存器并将此页号与高速缓存中的所有页号进行比较若其中有与此相匹配的页号便表示所要访问的页表项在快表中于是可直接从快表中读出该页所对应的物理块号并送到物理地址寄存器中如在块表中未找到对应的页表项则还须再访问内存中的页表找到后把从页表项中读出的物理块号送地址寄存器同时再将此页表项存入快表的一个寄存器单元中亦即重新修改快表分段存储管理方式分段存储管理方式的引入好处方便编程信息共享信息保护适应段的动态增长需求动态连接分段系统的基本原理在分段存储管理方式中作业的地址空间被划分为若干个段每个段定义了一组逻辑信息例如有主程序段子程序段数据段及栈段等分段地址中的地址具有如下结构在该地址结构中允许一个作业最长有个段每个段的最大长度为段表在分段式存储管理系统中则是为每个分段分配一个连续的分区而进程中的各个段可以离散地移入内存中不同的分区中为使程序能正常运行亦即能从物理内存中找出每个逻辑段所对应的位置应像分页系统那样在系统中为每个进程建立一张段映射表简称段表每个段在表中占有一个表项其中记录了该段在内存中的起始地址又称为基址和段的长度地址变换机构分段和分页的主要区别重点两者都采用离散分配方式且都要通过地址映射机构来实现地址变换但在概念上两者完全不同主要表现在下述三个方面页是信息的物理单位分页是为了实现离散分配方式以消减内存的外零头提高内存的利用率或者说分页仅仅是系统管理的需要而不是用户的需要段则是信息的逻辑单位分段得到目的是为了更好的满足用户的需求页的大小固定且由系统来决定而段的长度却不固定决定于用户编写的程序分页的作业地址空间是一维的分段的作业地址空间时二维的既需要给出段名有需要给出段内地址六虚拟存储器虚拟存储器的定义和特征重要定义基于局部性原理在程序装入时可以将程序中很快会用到的部分装入内存暂时用不到的部分留在外存就可以让程序开始执行在程序执行过程中当所访问的信息不在内存时由操作系统负责将所需信息从外存调入内存然后继续执行程序若内存空间不够由操作系统负责将内存中暂时用不到的信息换出到内存在操作系统的管理下在用户看来似乎有一个比实际内存大得多的内存这就是虚拟内存虚拟内存有以下三个特征多次性无需在作业运行时一次性全部装入内存而是允许被分成多次调入内存对换性在作业运行时无需一直常驻内存而是允许在作业运行过程中将作业换入换出虚拟性从逻辑上扩充了内存的容量使用户看到的内存容量远大于实际的容量请求分页存储管理方式请求分页存储管理与基本分页存储管理的主要区别在程序执行过程中当所访问的信息不在内存时由操作系统负责将所需信息从外存调入内存然后继续执行程序操作系统要提供请求调页功能将缺失页面从外存调入内存若内存空间不足由操作系统负责将内存中暂时用不到的信息换出内存操作系统要提供页面置换功能将暂时用不到的页面换出内存页表机制缺页中断机构在请求分页系统中每当所要访问的页面不在内存时便产生一缺页中断请求将所缺之页调入内存缺页中断作为中断它们同样需要经历诸如保护环境分析中断原因转入缺页中断处理程序进行处理恢复环境等几个步骤但缺页中断又是一种特殊的中断它与一般的中断相比有着明显的区别主要表现在下面两个方面在指令执行期间产生和处理中断信号一条指令在执行期间可能产生多次缺页中断地址变换机构页面置换算法重要最佳置换算法最佳置换算法每次选择淘汰的页面将是以后永不使用或者在最长时间内不再被访问的页面这样可以保证最低的缺页率最佳置换算法可以保证最低的缺页率但实际上只有在进程执行的过程中才能知道接下来会访问到的是哪个页面操作系统无法提前预判页面访问序列因此最佳置换算法是无法实现的先进先出置换算法该算法总是淘汰最先进入内存的页面即选择在内存中驻留时间最久的页面予以淘汰实现方法把调入内存的页面根据调入的先后顺序排成一个队列需要换出页面时选择对头页面即可队列的最大长度取决于系统为进程分配了多少个内存块异常当为进程分配的物理块增大时缺页次数不减反增现象缺点只有算法会产生异常另外虽然实现简单但是该算法与进程实际运行时的规律不适应因为先进入的页面也有可能是最经常被访问因此算法性能差最近最久未使用置换算法最近最久未使用置换算法每次淘汰的页面是最近最久未使用的页面实现方法赋予每个页面对应的页表项中用访问字段记录该页面自上次被访问以来所经历的时间当需要淘汰一个页面时选择现有页面中值最大的即最近最久未使用的页面在手动做题时若需要淘汰页面可以逆向检查此时在内存中几个页面在逆向扫描过程中最后一个出现的页号就是要淘汰的页面时钟置换算法最佳置换算法性能最好但无法实现先进先出置换算法实现简单但性能差最近最久未使用置换算法性能好是最接近最佳置换算法但是实现起来需要专门的硬件支持算法开销大时钟置换算法是一种性能和开销较均衡的算法又称算法或最近未用算法简单的置换算法当采用简单算法时只需为每页设置一位访问位再将内存中的所有页面都通过链接指针链接成一个循环队列当某页被访问时其访问位被置置换算法在选择一页淘汰时只需检查页的访问位如果是就选择该页换出若为则重新将它置暂不换出而给该页第二次驻留内存的机会再按照算法检查下一个页面当检查到队列中的最后一个页面时若其访问位仍为则再返回到队首去检查第一个页面改进型置换算法在将一个页面换出时如果该页已被修改过便须将该页重新写回到磁盘上但如果该页未被修改过则不必将它拷回磁盘在改进型算法中除须考虑页面的使用情况外还须再增加一个因素即置换代价这样选择页面换出时既要是未使用过的页面又要是未被修改过的页面把同时满足这两个条件的页面作为首选淘汰的页面由访问位和修改位可以组合成下面四种类型的页面类表示该页最近既未被访问又未被修改是最佳淘汰页类表示该页最近未被访问但已被修改并不是很好的淘汰页类表示该页最近已被访问但未被修改该页有可能再被访问类表示该页最近已被访问且被修改该页可能再被访问从指针所指示的当前位置开始扫描循环队列寻找且的第一类页面将所遇到的第一个页面作为所选中的淘汰页在第一次扫描期间不改变访问位如果第一步失败即查找一周后未遇到第一类页面则开始第二轮扫描寻找且的第二类页面将所遇到的第一个这类页面作为淘汰页在第二轮扫描期间将所有扫描过的页面的访问位都置如果第二步也失败亦即未找到第二类页面则将指针返回到开始的位置并将所有的访问位复然后重复第一步如果仍失败必要时再重复第二步此时就一定能找到被淘汰的页各算法总结七输入输出系统系统的层次结构和模型通常把软件组织分成四个层次如图所示用户层软件实现与用户交互的接口用户可之后可直接调用用户层提供的与操作有关的库函数对设备进行操作设备独立性软件负责实现与设备驱动器的统一接口设备命名设备的保护以及设备的分配与释放等同时为设备管理和数据提供必要的存储空间设备驱动程序与硬件直接相关负责具体实现系统对设备发出的操作指令驱动设备工作的驱动程序中断处理程序用户保存被中断进程的环境转入相应的中端程序进行处理产后护理完会后再恢复被中断进程的现场后返回到被中断进程设备和设备控制器设备的分类设备的类型繁多从观点看其重要的性能指标有设备使用特性数据传输速率数据的传输单位设备共享属性等因而可从不同角度对它们进行分类按使用特性分存储设备输入输出设备按传输速率分低速设备中速设备高速设备按信息交换分块设备字符设备按设备的共享属性分独占设备共享设备虚拟设备设备与控制器之间的接口设备并不是直接进行通信而是与设备控制器通信因此在设备中应含有与设备控制器间的接口因此在设备中应含有与设备控制器间的接口在接口中有三种类型的信号各对应一条信号线数据型号线用于设备与设备控制器之间传送数据信号控制信号线作为由设备控制器向设备发送控制信号时的通路状态信号线用于传送指示设备与当前状态的信号设备控制器基本功能接收和识别命令数据交换标识和报告设备的状态地址识别数据缓冲差错控制中断机构和中断处理程序中断简介中断和陷入中断对发出的中断信号的一种响应陷入内部事件引发的上溢或下溢中断向量表和中断优先级中断向量表保存中断处理程序的入口地址中断优先级键盘打印机磁盘多中断源的处理方式屏蔽中断嵌套中断中断处理对于不同的设备有不同的中断处理程序该程序首先从设备控制器读出设备状态以判别本次中断是正常完成中断还是异常结束中断若是前者中断程序便进行结束处理若还有命令可再向控制器发送新的命令进行新一轮的数据传送若是异常结束中断则根据发生异常的原因做相应的处理控制方式程序方式也称忙等待方式即在处理机向控制器发出一条指令启动输入设备输入数据时要同时把状态寄存器中的忙闲标志置为然后便不断地循环测试当时表示输入机尚未输完一个字符处理机应继续对该标志进行测试直至表明输入机已将输入数据送入控制器的数据寄存器中于是处理机将数据寄存器中的数据取出送入内存指定单元中这样便完成了一个字符的接着再去启动读下一个数据并置中断驱动控制方式引入中断机构后当某进程要启动某个设备工作时便由向相应的设备控制器发出一条命令然后立即返回继续执行原来的任务设备控制器于是按照该命令的要求去控制指定设备此时与设备并行操作例如在输入时当设备控制器收到发来的读命令后便去控制相应的输入设备读数据一旦数据进入数据寄存器控制器便通过控制线向发送一中断信号由检查输入过程中是否出错若无错便向控制器发送取走数据的信号然后再通过控制器及数据线将数据写入内存指定单元中直接存储器访问控制方式虽然中断驱动比程序方式更有效但须注意它仍是以字节为单位进行的每当完成一个字节的时控制器便要向请求一次中断换言之采用中断驱动方式时的是以字节为单位进行干预的如果将这种方式用于块设备的显然是极其低效的例如为了从磁盘中读出的数据块需要中断次为了进一步减少对的干预而引入了直接存储器访问方式该方式的特点是数据传输的基本单位是数据块即在与设备之间每次传送至少一个数据块所传送的数据是从设备直接送入内存的或者相反仅在传送一个或多个数据块的开始和结束时才需干预整块数据的传送是在控制器的控制下完成的可见方式较之中断驱动方式又是成百倍地减少了对的干预进一步提高了与设备的并行操作程度通道控制方式虽然方式比起中断方式来已经显著地减少了的干预即已由以字节为单位的干预减少到以数据块为单位的干预但每发出一条指令也只能去读或写一个连续的数据块而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域或者相反时则须由分别发出多条指令及进行多次中断处理才能完成通道方式是方式的发展它可进一步减少的干预即把对一个数据块的读或写为单位的干预减少为对一组数据块的读或写及有关的控制和管理为单位的干预同时又可实现通道和设备三者的并行操作从而更有效地提高整个系统的资源利用率例如当要完成一组相关的读或写操作及有关控制时只需向通道发送一条指令以给出其所要执行的通道程序的首址和要访问的设备通道接到该指令后通过执行通道程序便可完成指定的任务四种控制方式的总结与比较设备分配设备分配中数据结构设备控制表系统为每一个设备都配置了一张设备控制表用于记录本设备的情况控制器控制表用于记录本控制器情况的控制器控制表通道控制表每个通道都配有一张通道控制表系统设备表这是系统范围的数据结构其中记录了系统中全部设备的情况每个设备占一个表目其中包括有设备类型设备标识符设备控制表及设备驱动程序的入口等项分配设备首先根据请求中的物理设备名查找系统设备表从中找出该设备的再根据中的设备状态字段可知该设备是否正忙若忙便将请求进程的挂在设备队列上否则便按照一定的算法来计算本次设备分配的安全性如果不会导致系统进入不安全状态便将设备分配给请求进程否则仍将其插入设备等待队列在系统把设备分配给请求的进程后再到其中找出与该设备连接的控制器的从的状态字段中可知该控制器是否忙碌若忙便将请求进程的挂在该控制器的等待队列上否则便将该控制器分配给进程在该中又可找到与该控制器连接的通道的再根据内的状态信息可知该通道是否忙碌若忙便将请求的进程挂在该通道的等待队列上否则将该通道分配给进程只有在设备控制器和通道三者都分配成功时这次的设备分配才算成功然后便可启动该设备进行数据传送磁盘调度算法先来先服务根据进程请求访问磁盘的先后次序进行调度此算法的优点是公平简单且每个进程的请求都能依次地得到处理不会出现某一进程的请求长期得不到满足的情况但此算法由于未对寻道进行优化致使平均寻道时间可能较长最短寻道时间优先其要求访问的磁道与当前磁头所在的磁道距离最近以使每次的寻道时间最短但这种算法不能保证平均寻道时间最短基于扫描的磁盘调度算法算法虽然能获得较好的寻道性能但却可能导致某个进程发生饥饿现象因为只要不断有新进程的请求到达且其所要访问的磁道与磁头当前所在磁道的距离较近这种新进程的请求必然优先满足对算法略加修改后所形成的算法即可防止老进程出现饥饿现象算法该算法不仅考虑到欲访问的磁道与当前磁道间的距离更优先考虑的是磁头当前的移动方向例如当磁头正在自里向外移动时算法所考虑的下一个访问对象应是其欲访问的磁道既在当前磁道之外又是距离最近的这样自里向外地访问直至再无更外的磁道需要访问时才将磁臂换向为自外向里移动循环扫描算法算法既能获得较好的寻道性能又能防止饥饿现象故被广泛用于大中小型机器和网络中的磁盘调度但也存在这样的问题当磁头刚从里向外移动而越过了某一磁道时恰好又有一进程请求访问此磁道这时该进程必须等待待磁头继续从里向外然后再从外向里扫描完所有要访问的磁道后才处理该进程的请求致使该进程的请求被大大地推迟为了减少这种延迟算法规定磁头单向移动例如只是自里向外移动当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访问的磁道亦即将最小磁道号紧接着最大磁道号构成循环进行循环扫描',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-11 20:42:06',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/touxiang.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaofusu" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://space.bilibili.com/651626088?spm_id_from=333.1007.0.0" title="哔站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="哔站"/><span class="back-menu-item-text">哔站</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaofusu/My_Takeaway" title="小吴外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="小吴外卖"/><span class="back-menu-item-text">小吴外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/wu-zhiyifs/regiee" title="瑞吉外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="瑞吉外卖"/><span class="back-menu-item-text">瑞吉外卖</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小扶苏</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2312165875&amp;server=netease/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/weixin.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/img/weixin.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zhifubao.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/zhifubao.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gateway/" style="font-size: 1.05rem;">Gateway<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 1.05rem;">HashMap<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/OpenFeign/" style="font-size: 1.05rem;">OpenFeign<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>18</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>8</sup></a><a href="/tags/maven/" style="font-size: 1.05rem;">maven<sup>1</sup></a><a href="/tags/nacos/" style="font-size: 1.05rem;">nacos<sup>1</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>4</sup></a><a href="/tags/springboot/" style="font-size: 1.05rem;">springboot<sup>3</sup></a><a href="/tags/springcloud/" style="font-size: 1.05rem;">springcloud<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 1.05rem;">八股<sup>8</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>4</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url">操作系统</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>操作系统</span></a></span></div></div><h1 class="post-title" itemprop="name headline">操作系统知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-07T08:31:48.000Z" title="发表于 2023-12-07 16:31:48">2023-12-07</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-11T12:42:06.080Z" title="更新于 2023-12-11 20:42:06">2023-12-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">20.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统知识点总结"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为淮南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>淮南</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/aust3.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"><header><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url">操作系统</a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">操作系统</a><h1 id="CrawlerTitle" itemprop="name headline">操作系统知识点总结</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小吴顶呱呱</span><time itemprop="dateCreated datePublished" datetime="2023-12-07T08:31:48.000Z" title="发表于 2023-12-07 16:31:48">2023-12-07</time><time itemprop="dateCreated datePublished" datetime="2023-12-11T12:42:06.080Z" title="更新于 2023-12-11 20:42:06">2023-12-11</time></header><h1>一、操作系统概述</h1>
<h2 id="1-1-操作系统的定义与目标">1.1 操作系统的定义与目标</h2>
<p>定义：操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。</p>
<p>目标：方便性，有效性（提高系统资源的利用率、提高系统的吞吐量），可扩充性，开放性。</p>
<h2 id="1-2-操作系统的基本功能">1.2 操作系统的基本功能</h2>
<p>1.统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源</p>
<p>2.实现了对计算机资源的抽象：IO设备管理软件提供读写接口，文件管理软件提供操作文件接口</p>
<p>3.提供了用户与计算机之间的接口：GUI图形用户界面，命令形式，系统调用形式</p>
<h2 id="1-3-操作系统的特征（重点）">1.3 操作系统的特征（重点）</h2>
<p>最基本的特征，互为存在条件：并发，共享；</p>
<p><strong>1.并发</strong></p>
<p>（1）并行：俩个或多个时间可以在同一个时刻发生，多核cpu可以实现并行</p>
<p>（2）并发：同一个时间间隔发生，每个程序交替执行</p>
<p><strong>2.共享性</strong>：操作系统中的资源可以供多个并发的程序共同使用，称为资源共享。</p>
<ul>
<li>互斥共享：当资源被资源占用时，其他想使用的程序只能等待。</li>
<li>同时访问：某种资源并发的被多个程序访问</li>
</ul>
<p><strong>虚拟和异步性的前提是具有并发性</strong></p>
<p><strong>3.虚拟性</strong>：表现为把一个物理实体转变为若干个逻辑实体</p>
<ul>
<li>时分复用技术：资源在时间上进行复用，不同程序并发使用，多到程序使用计算机的硬件资源，提高资源的利用率</li>
<li>空分复用技术：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等提高资源的利用率，提高编程效率。</li>
</ul>
<p><strong>4.异步性</strong>：在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。</p>
<h2 id="1-4操作系统的中断处理">1.4操作系统的中断处理</h2>
<p>中断机制的作用：为了在多道批处理系统中让用户进行交互；</p>
<p><strong>中断的产生：</strong></p>
<ul>
<li>发生中断时，cpu立马切换到管态，开展管理工作（管态又叫特权态，系统态或者核心态，是操作系统管理的程序执行时，机器所处的状态）</li>
<li>发生中断后，当前运行的进程会暂停运行，由操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<p><strong>中断的分类：</strong></p>
<p>1.内中断（也叫异常、例外、陷入）------信号来源：CPU内部，与当前执行指令有关</p>
<p>2.外中断（中断）---------信号来源：cpu外部，与当前执行指令无关</p>
<h2 id="1-5操作系统的发展与分类（重点）">1.5操作系统的发展与分类（重点）</h2>
<ol>
<li>
<p>手工操作阶段：用户独占全机，人机速度矛盾导致资源利用率极低</p>
</li>
<li>
<p>单道批处理</p>
<p>引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出</p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</p>
<p>缺点：内存中仅仅能有一道程序运行，只有该程序运行结束之后才能调入下一道2程序。cpu有大量的时间是在空闲等待I/0完成，资源利用率依然很低</p>
</li>
<li>
<p>多道批处理</p>
<p>主要优点：多道程序并发执行，共享计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，<strong>系统吞吐量增大</strong>。</p>
<p>缺点：用户相应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后只能等待计算机处理完成，中间不能控制自己的作业执行，比如无法调试程序/无法在程序运行过程中输入一些参数）</p>
</li>
<li>
<p>分时操作系统</p>
<p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端与计算机<strong>进行交互</strong>。</p>
<p>主要优点：用户请求可以被及时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环的为每个用户/作业服务一个时间片，不区分任务的紧急性</p>
</li>
<li>
<p>实时操作系统</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p>
<p>主要优点：能够响应一些紧急的任务某些紧急任务不需要时间片排队</p>
</li>
</ol>
<h2 id="1-6操作系统的主要功能（重点）">1.6操作系统的主要功能（重点）</h2>
<ol>
<li>处理机管理功能</li>
<li>存储器管理功能</li>
<li>设备管理功能</li>
<li>文件管理功能</li>
<li>接口管理功能</li>
</ol>
<h1>二、进程管理</h1>
<h2 id="2-1进程的定义">2.1进程的定义</h2>
<p>为什么需要进程：</p>
<ol>
<li>进程是系统进行资源分配和调度的基本单位</li>
<li>进程作为程序独立运行的载体保障程序正常执行</li>
<li>进程的存在使得操作系统资源的利用率大幅提升</li>
</ol>
<p><strong>什么是进程：进程是程序的执行过程，是系统进行资源分配和调度的一个独立单位。</strong></p>
<p>进程控制块（PCB）：用于描述和控制进程运行的通用数据结构，<strong>记录进程当前状态和控制进程运行的全部信息，是进程存在的唯一标识</strong></p>
<p>进程与线程：</p>
<ul>
<li>线程：操作系统进行<strong>运行调度的最小单位</strong>。</li>
<li>进程：系统进行<strong>资源分配和调度的基本单位</strong>。</li>
</ul>
<p>区别与联系：</p>
<ol>
<li>一个进程可以有一个或多个线程</li>
<li>线程包含在进程之中，是进程中实际运行工作的单位</li>
<li>进程的线程共享进程资源</li>
<li>一个进程可以并发多个线程，每个线程执行不同的任务</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/57105faf208a76086d4ae131c69d5cc0.png" alt="img"></p>
<h2 id="2-2进程的五个特性">2.2进程的五个特性</h2>
<ol>
<li>动态性：进程具有生命周期。它由系统“创建”而诞生，被调度而执行，，因得不到资源而暂停，最后因被“撤销”而消亡</li>
<li>并发性：不同进程的动作在时间上可以重叠，即系统内的多个进程是可以并发执行的。</li>
<li>独立性：进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调动的基本单位。在今天既有进程又有线程的操作系统中，进程是一个能独立运行的基本单位，但不再是一个可执行的实体，系统独立运行的基本单位变成线程了。</li>
<li>异步性：进程按各自独立的、不可预知的速度向前推进。不可预知的原因是并发执行。</li>
<li>结构特性：从结构上看，每个进程都由程序段、数据段和一个PCB三部分组成。</li>
</ol>
<h2 id="2-3进程的基本状态与转换（重点）">2.3进程的基本状态与转换（重点）</h2>
<h3 id="2-3-1-进程的三种基本状态">2.3.1 进程的三种基本状态</h3>
<ol>
<li>就绪（ready）状态：当进程已分配到 除CPU外的所有需要的资源，只要再获得处理机（CPU）的资源，便可以立即执行。</li>
<li>执行（running）状态：：当进程已获得处理机资源，其资源正在处理机上执行。</li>
<li>阻塞（Block）状态：正在执行的进程由于等待某个事件发生而无法执行时，便放弃处理机资源而处于阻塞状态。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/C5_17%7DF_R91GT9_1PRF3@B3_tmb.jpg" alt="img"></li>
</ol>
<h3 id="2-3-2-五状态转换模型">2.3.2 五状态转换模型</h3>
<p>在不少系统中，增加了两种基本状态：（1）新状态：进程刚被创建，并分配资源时；（2）终止状态：在进程结束后不会立即撤销进程，相应的进程会暂时留在系统中，以便收集进程的相关信息。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/OGU0L%60NU2CA%5B%60VXP_DO5%5DYO.jpg" alt="img"></p>
<h3 id="2-3-3-挂起操作和进程状态的转换">2.3.3 挂起操作和进程状态的转换</h3>
<p>在许多系统中，为了满足系统和用户观察与分析进程的需要，加入挂起这一重要操作。</p>
<p>引入挂起的目的：</p>
<ol>
<li>终端用户的需要。</li>
<li>父进程的需要</li>
<li>负荷调节的需要</li>
<li>OS的需要</li>
</ol>
<p>状态转换：活动就绪——&gt;禁止就绪；活动阻塞——&gt;禁止就绪；禁止就绪——&gt;活动就绪；禁止阻塞——&gt;活动阻塞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/0147D84CE35405EAECD5D488C147BAF0.jpg" alt="img"></p>
<h2 id="2-4-进程控制块PCB">2.4 进程控制块PCB</h2>
<h3 id="2-4-1-PCB的定义">2.4.1 PCB的定义</h3>
<ul>
<li>PCB是系统为了描述和控制进程的运行而为进程定义的一种数据结构</li>
<li>PCB是进程实体的一部分，是进程存在的唯一标志，也是操作系统中最重要的结构体类型的数据结构</li>
<li>PCB中存放着操作系统所需要的用于描述进程当前情况以及控制进程运行的全部信息</li>
</ul>
<h3 id="2-4-2-PCB的作用">2.4.2 PCB的作用</h3>
<ol>
<li>作为独立运行基本单位的标志</li>
<li>实现间断性运行方式</li>
<li>提供进程管理所需的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步和通信</li>
</ol>
<h3 id="2-4-3-PCB中的信息">2.4.3 PCB中的信息</h3>
<ul>
<li>进程标识符：系统内用于标识一个进程的唯一编号</li>
<li>处理机状态</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
</ul>
<h2 id="2-5-线程与进程的比较">2.5 线程与进程的比较</h2>
<p>从调度的基本单位、并发性、拥有资源等方面对线程和进程进行比较</p>
<ol>
<li>
<p>调度的基本单位</p>
<p>在传统OS中，进程作为独立调度和分派的基本单位，能够独立运行，其在每次被调度时候，都需要进行上下文切换，开销较大。而在引入线程的OS中，已经把线程作为调度和分派的基本单位，因而线程是能够独立运行的基本单位。在同一个进程中，，线程的切换不会引起进程的切换，但进程的切换必然引起线程的切换。</p>
</li>
<li>
<p>并发性</p>
<p>不同的进程之间可以并发执行，而且在一个进程中的多个线程也可以并发执行，还允许一个进程中的所有线程可以并发执行。不同进程中的线程也可以并发执行。</p>
</li>
<li>
<p>拥有资源</p>
<p>进程可以拥有资源，并可以作为系统中拥有资源的一个基本单位，然而，线程几乎不拥有资源。</p>
</li>
<li>
<p>独立性</p>
<p>在同一个进程中的不同线程之间的独立性，要比不同进程之间的独立性差很多。</p>
</li>
<li>
<p>系统开销</p>
<p>创建进程的系统开销远大于创建线程</p>
</li>
<li>
<p>支持多处理机系统</p>
<p>对于传统进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，可以将一个进程中的多个线程分配到多个处理机上，并行运行，加快进程的完成。</p>
</li>
</ol>
<h1>三、处理机调度与死锁</h1>
<h2 id="3-1-处理机调度的层次和调度算法的目标">3.1 处理机调度的层次和调度算法的目标</h2>
<ol>
<li>高级调度：作业调度，几个作业调入内存，为它们创建进程分配必要的资源（外存——&gt;内存）</li>
<li>低级调度：进程调度，调度的对象是进程或者内核级线程（内存——&gt;处理机）</li>
<li>中级调度：内存调度。暂时不能运行的进程调至外存等待（外存&lt;——&gt;内存）</li>
</ol>
<p>处理机调度算法的共同目标：1、资源利用率 ：主要是CPU利用率 2、公平性：获得合理的CPU时间</p>
<p>3、平衡性：进程类型，计算型，输入/输出型 4、策略强制执行：系统的安全策略</p>
<p>批处理系统的目标：1、平均周转时间 2、系统吞吐量 3、处理机利用率</p>
<p>分时系统的目标：1、响应速度快 2、均衡性</p>
<p>实时系统的目标：1、截止时间 2、可预测性</p>
<h2 id="3-2-作业与作业调度（重点）">3.2 作业与作业调度（重点）</h2>
<p>作业：作业是一个比程序更为广泛的概念，他不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存。</p>
<p>作业调度的主要任务：根据作业控制块（JCB）中的信息，审查系统能否满足用户作业的资源需求，以及按照一定的算法，从外存的后背队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程插入就绪队列，准备执行。</p>
<h3 id="3-2-1-先来先服务调度算法（FCFS">3.2.1 先来先服务调度算法（FCFS)</h3>
<p>该算法既可用于作业调度，也可用于进程调度，非抢占式。该算法每次调度都是从后背作业中选择一个或者多个<strong>最先进入该队列的作业</strong>，将它们调入内存，为它们分配资源，创建进程，然后放入就绪队列。</p>
<p>先来先服务算法比较<strong>有利于长作业（进程），而不利于短作业（进程）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208134522826.png" alt="image-20231208134522826"></p>
<h3 id="3-2-2-短作业优先调度算法-SJF">3.2.2 短作业优先调度算法(SJF)</h3>
<p>为了追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间，每次调度时选择<strong>当前已到达且最短</strong>的作业/进程优先的到服务，所谓的最短也就是服务时间最短，即可用于作业调度也可用于进程调度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208140717340.png" alt="image-20231208140717340"></p>
<p>采用短作业优先不论是平均周转时间还是平均带权周转时间都有明显的改善。所以短作业优先可以有效降低作业的平均等待时间，提高系统吞吐量。</p>
<p>缺点：</p>
<ol>
<li>该算法对长作业不利。可能产生长作业饥饿</li>
<li>未考虑作业的紧迫程度，因此不能保证紧迫性作业（程序）会被及时处理</li>
<li>由于作业（进程）的长短只是根据用户所提供的的估计执行时间定的，而用户有可能会有意或无意缩短其作业的估计运行时间，致使该算法不一定能做到短作业优先调度。</li>
</ol>
<h3 id="3-2-3-高优先权优先调度算法-HRRN">3.2.3 高优先权优先调度算法(HRRN)</h3>
<p>当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p>
<ol>
<li>非抢占式优先权算法：系统一旦吧处理机分配给就绪队列中优先权最高的进程后，该进程就会一直执行下去，直至完成；</li>
<li>抢占式优先权调度算法：在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。这种抢占式的更好地满足紧迫作业的要求。</li>
</ol>
<p>确定进程优先权的依据：</p>
<ul>
<li>进程类型。通常，系统进程(如接收进程、对换进程、磁盘I/O进程)的优先权高于一般用户进程的优先权。</li>
<li>进程对资源的需求。如进程的估计执行时间及内存需要量的多少，对这些要求少的进程应赋予较高的优先权。</li>
<li>用户要求。这是由用户进程的紧迫程度及用户所付费用的多少来确定优先权的。</li>
</ul>
<p><strong>高响应比优先调度算法：</strong></p>
<p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208144852613.png" alt="image-20231208144852613"></p>
<p>由上式可以看出：<br>
　　(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。<br>
　　(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p>
<p>(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。<br>
　　简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销</p>
<h3 id="3-2-4-基于时间片的轮转调度算法-RR">3.2.4 基于时间片的轮转调度算法(RR)</h3>
<p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到相应</p>
<p>原理：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如：100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。只用于进程调度（只有当作业放入内存建立了相应的进程后，才能被分配处理机时间片），抢占式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208152141559.png" alt="image-20231208152141559"></p>
<h3 id="3-2-5-多级反馈队列调度算法">3.2.5 多级反馈队列调度算法</h3>
<p>(1)应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208152814494.png" alt="image-20231208152814494"></p>
<p>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。</p>
<p>(3) 按队列优先级调度，仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程</p>
<h2 id="3-3-实时调度（重点）">3.3 实时调度（重点）</h2>
<p>实现实时调度的基本条件</p>
<ol>
<li>提供必要的信息
<ul>
<li>就绪时间</li>
<li>开始时间和截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强</li>
</ol>
<h3 id="3-3-1-最早截止时间优先算法">3.3.1 最早截止时间优先算法</h3>
<p>该算法是根据任务的开始截止时间来确定任务的优先级。截止时间越早，其优先级越高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的早晚排序，具有最早截止时间的任务排在队列的最前面。调度程序在选择任务时，总是选择就绪队列的第一个任务，即可用于抢占式调度，也可用于非抢占式调度。</p>
<ul>
<li>
<p>非抢占式调度方式用于非周期实时任务</p>
<p>如下图所示将该算法用于非抢占调度方式之例。该例中具有四个非周期任务，它们先后到达。系统首先调度任务1执行，在任务1执行期间，任务2、3又先后到达。由于任务3的开始截止时间早于任务2，故系统在任务1后将调度任务3执行。在此期间又到达作业4，其开始截止时间仍是早于任务2的，故在任务3执行完后，系统又调度任务4执行，最后才调度任务2执行。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208155752571.png" alt="image-20231208155752571"></p>
<ul>
<li>
<p>抢占式调度方式用于周期实时任务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208160704217.png" alt="image-20231208160704217"></p>
</li>
</ul>
<p>为了说明通常的优先级调度不能适用于实时系统，该图特增加了第二和第三行。在第二行中假定任务A具有较高的优先级，所以在t=0 ms时，先调度A1执行，在A1完成后(t = 10 ms)才调度B1执行；在t = 20 ms时，调度A2执行；在t = 30 ms时，A2完成，又调度B1执行；在t = 40 ms时，调度A3执行；在t = 50 ms时，虽然A3已完成，但B1已错过了它的最后期限，这说明了利用通常的优先级调度已经失败。第三行与第二行类似，只是假定任务B具有较高的优先级</p>
<h3 id="3-3-2-最低松弛度优先算法">3.3.2 最低松弛度优先算法</h3>
<p>该算法是根据任务紧急的程度，来确定任务的优先级。任务的紧急程度越高，为该任务所赋予的优先级就越高，使之优先执行。该算法主要用于抢占式调度方式。</p>
<p>假如在一个实时系统中，有两个周期性实时任务A和B，任务A要求每 20 ms执行一次，执行时间为 10 ms；任务B只要求每50 ms执行一次，执行时间为 25 ms。由此可得知任务A和B每次必须完成的时间分别为：A1、A2、A3、…和B1、B2、B3、…，见图3-8。为保证不遗漏任何一次截止时间，应采用最低松弛度优先的抢占调度策略</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208161723722.png" alt="image-20231208161723722"></p>
<p>在刚开始时(t1 = 0)，A1必须在20 ms时完成，而它本身运行又需 10 ms，可算出A1的松弛度为10 ms；B1必须在50 ms时完成，而它本身运行就需25 ms，可算出B1的松弛度为25 ms，故调度程序应先调度A1执行。在t2 = 10 ms时，A2的松弛度可按下式算出：</p>
<p>A2的松弛度 = 必须完成时间 - 其本身的运行时间 - 当前时间<br>
  　　= 40 ms-10 ms-10 ms = 20 ms</p>
<p>类似地，可算出B1的松弛度为15 ms，故调度程序应选择B1运行。在t3 = 30 ms时，A2的松弛度已减为0(即40 - 10 - 30)，而B1的松弛度为15 ms(即50 - 5 - 30)，于是调度程序应抢占B1的处理机而调度A2运行。在t4 = 40 ms时，A3的松弛度为10 ms(即60 - 10 - 40)，而B1的松弛度仅为5 ms(即50 - 5 - 40)，故又应重新调度B1执行。在t5 = 45 ms时，B1执行完成，而此时A3的松弛度已减为5 ms(即60 - 10 - 45)，而B2的松弛度为30 ms(即100 - 25 - 45)，于是又应调度A3执行。在t6 = 55 ms时，任务A尚未进入第4周期，而任务B已进入第2周期，故再调度B2执行。在t7 = 70 ms时，A4的松弛度已减至0 ms(即80 - 10 - 70)，而B2的松弛度为20 ms(即100 - 10 - 70)，故此时调度又应抢占B2的处理机而调度A4执行。图3-9示出了具有两个周期性实时任务的调度情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231208161906458.png" alt="image-20231208161906458"></p>
<h2 id="3-4-死锁概述">3.4 死锁概述</h2>
<p>产生死锁的原因：</p>
<ul>
<li>
<p>竞争资源。</p>
</li>
<li>
<p>进程间推进顺序非法。进程在运行过程中，请求（wait）和释放（signal）资源的顺序不当。</p>
</li>
</ul>
<p>产生死锁的必要条件：</p>
<ul>
<li>
<p>互斥条件</p>
</li>
<li>
<p>请求和保持条件</p>
</li>
<li>
<p>不剥夺条件</p>
</li>
<li>
<p>环路等待条件</p>
</li>
</ul>
<p>处理死锁的基本方法：</p>
<ul>
<li>预防死锁：去破坏产生死锁的四个必要条件中的一个或者几个条件。</li>
<li>避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态</li>
<li>检测死锁：允许系统发生死锁，然后检测出死锁的发生，并精确确定与死锁有关的进程和资源，采取措施将死锁清除掉</li>
<li>解除死锁：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态。</li>
</ul>
<p>预防死锁的方法：</p>
<ol>
<li>
<p>破坏“请求和保持”条件：所有进程在开始运行之前，都必须一次性申请所需的全部资源。</p>
<p>优点：简单、易于实现且安全。</p>
<p>缺点：资源严重浪费；进程延迟运行</p>
</li>
<li>
<p>破坏“不可抢占”条件：一个进程申请其他资源而不能满足时，必须释放已有资源。</p>
</li>
<li>
<p>破坏“环路等待”条件：所有资源按类型进行线性排队。严格依次分配资源。</p>
</li>
</ol>
<h2 id="3-5-银行家算法（重点）">3.5 银行家算法（重点）</h2>
<p>文字太枯燥并且看不明白，去看个视频秒懂。</p>
<h1>四、进程同步</h1>
<h2 id="4-1-进程同步概念">4.1 进程同步概念</h2>
<p>俩种形式的制约关系：在多道程序环境下，当程序并发执行时，由于资源共享和进程合作，使同处于一个系统中的诸进程之间可能存在着俩种形式的制约关系：</p>
<ol>
<li>间接相互制约关系。同处于一个系统中的进程，通常都共享着某种系统资源，如共享CPU、共享I/O设备等。所谓间接相互制约即源于这种资源共享，例如，有两个进程A和B，如果在A进程提出打印请求时，系统已将惟一的一台打印机分配给了进程B，则此时进程A只能阻塞；一旦进程B将打印机释放，则A进程才能由阻塞改为就绪状态。</li>
<li>直接相互制约关系。这种制约主要源于进程间的合作。例如，有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程因不能获得所需数据而阻塞，而当进程A数据输入输入缓冲区后，便将进程B唤醒；反之，当缓冲区已满时，进程A因不能再向缓冲区投放数据而阻塞，当进程B将缓冲区数据取走后便可唤醒A。</li>
</ol>
<p>临界区：不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。人们把在每个进程中<strong>访问临界资源的那段代码称为临界区(critical section)</strong>。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。为此，每个进程在进入临界区之前，应先对欲访问的<strong>临界资源进行检查</strong>，看它<strong>是否正被访问</strong>。如果此刻该临界资源<strong>未被访问，进程便可进入临界区对该资源进行访问</strong>，并设置它正被访问的标志；如果此刻该临界资源**正被某进程访问，则本进程不能进入临界区。**因此，必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区(entry section)。相应地，在临界区后面也要加上一段称为退出区(exit section)的代码，用于将临界区正被访问的标志恢复为未被访问的标志。</p>
<h2 id="4-2-信号量机制（重点）">4.2 信号量机制（重点）</h2>
<h3 id="4-2-1-整型信号量（了解即可）">4.2.1 整型信号量（了解即可）</h3>
<p>最初由Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic Operation) wait(S)和signal(S)来访问。很长时间以来，这两个操作一直被分别称为P、V操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209134920525.png" alt="image-20231209134920525"></p>
<p>wait(S)和signal(S)是两个原子操作，因此，它们在执行时是不可中断的。亦即，当一个进程在修改某信号量时，没有其他进程可同时对该信号量进行修改。此外，在wait操作中，对S值的测试和做S:=S-1操作时都不可中断。</p>
<h3 id="4-2-2-记录型信号量（重要）">4.2.2 记录型信号量（重要）</h3>
<p>在整型信号量机制中的wait操作，只要是信号量S≤0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。用记录型数据结构表表示的信号量。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209134631041.png" alt="image-20231209134631041"></p>
<p>相应地，wait(S)和signal(S)操作可描述为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209134837919.png" alt="image-20231209134837919"></p>
<p>在记录型信号量机制中，S.value的初值表示系统中某类资源的数目，因而又称为资源信号量。对它的每次wait操作，意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源数减少一个，因此描述为S.value-- ；当S.value&lt;0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.L中。可见，该机制遵循了“让权等待”准则。此时S.value的绝对值表示在该信号量链表中已阻塞进程的数目。对信号量的每次signal操作，表示执行进程释放一个单位资源，使系统中可供分配的该类资源数增加一个，故S.value++操作表示资源数目加1。若加1后仍是S.value≤0，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L链表中的第一个等待进程唤醒。如果S.value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量，用于进程互斥。</p>
<h3 id="4-2-3-AND型信号量">4.2.3 AND型信号量</h3>
<p>AND同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。亦即，对若干个临界资源的分配，采取原子操作方式：要么把它所请求的资源全部分配到进程，要么一个也不分配。由死锁理论可知，这样就可避免上述死锁情况的发生。为此，在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作，即Swait( Simultaneous wait)定义如下:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1，S2，…，Sn)</span><br><span class="line">　　if (Si&gt;=1 and … and Sn&gt;=1) then</span><br><span class="line">　　　for i:=1 to n 　　　Si:=Si-1；</span><br><span class="line">　　else</span><br><span class="line">　　place the process in the waiting queue associated with the first Si found with Si&lt;1，and set the program count of this process to the beginning of Swait operation </span><br><span class="line">　　endif</span><br><span class="line"></span><br><span class="line">Ssignal(S1，S2，…，Sn)</span><br><span class="line"> for i:=1 to n do　　Si:=Si+1；</span><br><span class="line">Remove all the process waiting in the queue associated with Si into the ready queue.</span><br><span class="line">endfor； </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-3-信号量的应用">4.3 信号量的应用</h2>
<ol>
<li>
<p>利用信号量实现进程互斥</p>
<p>为了使多个进程能够互斥地访问某个临界资源，只需为该资源设置一个互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex执行wait操作，若该资源此刻未被访问，本次wait操作必然成功，进程便可进入自己的临界区，这时若再有其他进程也欲进入自己的临界区，此时由于对mutex执行wait操作定会失败，因而该进程阻塞，从而保证了该临界资源能被互斥地访问。当访问临界资源的进程退出临界区后，又应对mutex执行signal操作，以便释放该临界资源。</p>
<p>利用信号量实现进程互斥的进程可描述如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Var mutex: =1；</span><br><span class="line">　　begin</span><br><span class="line">　　parbegin</span><br><span class="line">　　　　process A: begin</span><br><span class="line">　　　　　　　　　　　 repeat</span><br><span class="line">　　　　　　　　　　　 　wait(mutex)；</span><br><span class="line">　　　　　　　　　　　 　critical section</span><br><span class="line">　　　　　　　　　　　 　signal(mutex)；</span><br><span class="line">　　　　　　　　　　　 　remainder section</span><br><span class="line">　　　　　　　　　　　 until false；</span><br><span class="line">　　　　　　　　　　 end </span><br><span class="line">        process B: begin</span><br><span class="line">                 repeat</span><br><span class="line">                  wait(mutex)；</span><br><span class="line">                  critical section</span><br><span class="line">                  signal(mutex)；</span><br><span class="line">                  remainder section</span><br><span class="line">                 until false；</span><br><span class="line">                end</span><br><span class="line">            parend </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用信号量实现前驱关系</p>
<p>如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209140756190.png" alt="image-20231209140756190"></p>
<p>利用信号量实现此前驱图：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a,b,c,d,e,f,g=0,0,0,0,0,0,0；</span><br><span class="line">　　　　p1() &#123; S1； signal(a)； signal(b) ； &#125;</span><br><span class="line">　　　　p2() &#123;wait(a)； S2； signal(c)； signal(d)；&#125;</span><br><span class="line">　　　　p3() &#123; wait(b)； S3； signal(e)；&#125;</span><br><span class="line">　　　　p4() &#123;wait(c)； S4； signal(f)； &#125;</span><br><span class="line">　　　　p5() &#123;wait(d)； S5； signal(g)； &#125;</span><br><span class="line">　　　　p6() &#123;wait(e)； wait(f)； wait(g)； S6；&#125;</span><br><span class="line">　　cobegin</span><br><span class="line">               p1()； p2()； p3()； p4()； p5()； p6()；</span><br><span class="line">　　coend </span><br><span class="line">注：控制变量可以根据有向边或节点数目定义；</span><br><span class="line">        节点入度为0进程可执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-4-经典进程的同步问题">4.4 经典进程的同步问题</h2>
<h3 id="4-4-1-生产者-消费者问题">4.4.1 生产者-消费者问题</h3>
<p>假定在生产者和消费者之间的公用缓冲池中，具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用。利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。对生产者—消费者问题可描述如下:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int in=0，out=0；</span><br><span class="line">array buffer[0，…，n-1]；</span><br><span class="line">semaphore mutex=1，empty=n，full=0；</span><br><span class="line">//生产者</span><br><span class="line">void producer()&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		producer an item nextp；</span><br><span class="line">　　　　　　　　　……　　</span><br><span class="line">         wait(empty)； //申请空闲缓冲区</span><br><span class="line">         wait(mutex)；//申请互斥信号量</span><br><span class="line">         buffer[in]=nextp；</span><br><span class="line">         in=(in+1) % n；</span><br><span class="line">         signal(mutex)；//释放互斥信号量</span><br><span class="line">         signal(full)；//释放满缓冲区</span><br><span class="line"></span><br><span class="line">	&#125;while(TRUE)</span><br><span class="line">&#125;</span><br><span class="line">//消费者</span><br><span class="line">void consumer()&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		wait(full)；//申请满缓冲区</span><br><span class="line">        wait(mutex)；//申请互斥信号量</span><br><span class="line">        nextc:=buffer(out)；</span><br><span class="line">        out=(out+1) % n；</span><br><span class="line">        signal(mutex)；//释放互斥信号量</span><br><span class="line">        signal(empty)；//释放空闲缓冲区</span><br><span class="line">		consumer the item in nextc；</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	&#125;while(TRUE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生产者—消费者问题中应注意：<br>
首先，在每个程序中用于实现互斥的wait(mutex)和signal(mutex)必须成对地出现；<br>
其次，对资源信号量empty和full的wait和signal操作，同样需要成对地出现，但它们分别处于不同的程序中。例如，wait(empty)在计算进程中，而signal(empty)则在消费进程中，计算进程若因执行wait(empty)而阻塞，则以后将由消费进程将它唤醒；<br>
最后，在每个程序中的多个wait操作顺序不能颠倒，应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁</p>
<h3 id="4-4-2-哲学家进餐问题">4.4.2 哲学家进餐问题</h3>
<p>放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopsticks[5]=&#123;1,1,1,1,1&#125;;</span><br><span class="line">do&#123;</span><br><span class="line">	wait(chopstick[i]);</span><br><span class="line">	wait(chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	//eat</span><br><span class="line">	...</span><br><span class="line">	signal(chopstick[i]);</span><br><span class="line">	signal(chopstick[(i+1)%5])</span><br><span class="line">	...</span><br><span class="line">	think;</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>
<p>在以上描述中，当哲学家饥饿时，总是先去拿他左边的筷子，即执行wait(chopstick[i])； 成功后，再去拿他右边的筷子，即执行wait(chopstick[(i+1)mod 5])；又成功后便可进餐。进餐完毕，又先放下他左边的筷子，然后再放右边的筷子。虽然，上述解法可保证不会有两个相邻的哲学家同时进餐，但有可能引起死锁。</p>
<p>假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0； 当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。对于这样的死锁问题，可采取以下几种解决方法：</p>
<ol>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家 的左右俩只筷子均可用时，才允许他拿起筷子进餐</li>
<li>规定偶数号哲学家先拿他左边的筷子，然后再去那右边的筷子，而奇数号相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。</li>
</ol>
<h3 id="4-4-3-读者-写者问题">4.4.3 读者-写者问题</h3>
<p>为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。另外，再设置一个整型变量Readcount表示正在读的进程数目。由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount=0，表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若Wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行signal(Wmutex)操作，以便让Writer进程写。又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，也应该为它设置一个互斥信号量rmutex。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">读者—写者问题可描述如下:</span><br><span class="line">　　Var rmutex，wmutex:=1,1；</span><br><span class="line">　　　　Readcount=0；</span><br><span class="line">　　Reader:  begin</span><br><span class="line">　　　　　　　　repeat</span><br><span class="line">　　　　　　　　　wait(rmutex)；</span><br><span class="line">　　　　　　　　　if readcount==0 then wait(wmutex)；</span><br><span class="line">　　　　　　　　　　Readcount:=Readcount+1；</span><br><span class="line">　　　　　　　　　signal(rmutex)；</span><br><span class="line"></span><br><span class="line">　　　　　　　 ………..perform read operation；</span><br><span class="line"></span><br><span class="line">　　　　　　　　　wait(rmutex)；</span><br><span class="line">　　　　　　　　　readcount:=readcount-1；</span><br><span class="line">　　　　　　　　　if readcount==0 then signal(wmutex)；</span><br><span class="line">　　　　　　　　　signal(rmutex)；</span><br><span class="line">    writer:  begin</span><br><span class="line">            repeat</span><br><span class="line">             wait(wmutex)；</span><br><span class="line">             perform write operation；</span><br><span class="line">             signal(wmutex)；</span><br><span class="line">            until false；</span><br><span class="line">           end</span><br><span class="line">        parend</span><br><span class="line">      end </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请给出一个写者优先的“读者-写者”问题的算法描述。(多个写进程连续写)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Reader：begin</span><br><span class="line">	repeat</span><br><span class="line">	wait(S);</span><br><span class="line">	wait(rmutex);</span><br><span class="line">	if readcount==0 </span><br><span class="line">		then wait(wmutex);</span><br><span class="line">	readcount=readcount+1;</span><br><span class="line">	signal(rmutex);</span><br><span class="line">	signal(S);</span><br><span class="line">	perform read operation;</span><br><span class="line">    wait(rmutex);</span><br><span class="line">    readcount=readcount-1;</span><br><span class="line">    if readcount==0 </span><br><span class="line">    then signal(wmutex); 	</span><br><span class="line">    signal(rmutex);</span><br><span class="line">    until false;</span><br><span class="line">    end;</span><br><span class="line">    </span><br><span class="line">writer：begin</span><br><span class="line">	repeat</span><br><span class="line">	wait(mutex);</span><br><span class="line">	if writecount==0 </span><br><span class="line">		then wait(S);</span><br><span class="line">	writecount=writecount+1;</span><br><span class="line">	signal(mutex);</span><br><span class="line">	wait(wmutex);</span><br><span class="line">	perform write operation;</span><br><span class="line">	signal(wmutex);	</span><br><span class="line">	wait(mutex);</span><br><span class="line">    writecount=writecount-1;</span><br><span class="line">    if writecount==0 </span><br><span class="line">    then signal(S); 	</span><br><span class="line">    signal(mutex);</span><br><span class="line">    until false;</span><br><span class="line">    end;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>五、存储器管理</h1>
<h2 id="5-1存储器的层次结构">5.1存储器的层次结构</h2>
<p>对于通用计算机而言，存储层次至少应具有三级：最高层为<strong>CPU寄存器，中间为主存，最底层是辅存</strong>。在较高档的计算机中，还可以根据具体的功能分工细划为寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动存储介质等6层。如图4-1所示，在存储层次中越往上，存储介质的访问速度越快，价格也越高，相对存储容量也越小。其中，寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。固定磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209165040331.png" alt="image-20231209165040331"></p>
<h2 id="5-2-程序的装入和链接">5.2 程序的装入和链接</h2>
<p>将一个用户源程序变为一个可在内存中执行的程序，通常都要经过以下几个步骤：首先是要编译，由编译程序(Compiler)将用户源代码编译成若干个目标模块(Object Module)；其次是链接，由链接程序(Linker)将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load Module)；最后是装入，由装入程序(Loader)将装入模块装入内存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209165246877.png" alt="image-20231209165246877"></p>
<h3 id="5-2-1-三种装入方式">5.2.1 三种装入方式</h3>
<ol>
<li>
<p>绝对装入方式</p>
<p>在编译时，如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不须对程序和数据的地址进行修改。</p>
<p>绝对装入方式只能**将目标模块装入到内存中事先指定的位置。**在多道程序环境下，编译程序不可能预知所编译的目标模块应放在内存的何处，因此，<strong>绝对装入方式只适用于单道程序环境。</strong></p>
</li>
<li>
<p>可重定位装入方式</p>
<p>在多道程序环境下，所得到的目标模块的起始地址通常是从0开始的，程序中的其它地址也都是相对于起始地址计算的。此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。</p>
<p>可重定位装入方式<strong>可将装入模块装入到内存中任何允许的位置</strong>，故可用于多道程序环境；但这种方式并<strong>不允许程序运行时在内存中移动位置。</strong></p>
</li>
<li>
<p>动态运行时装入方式</p>
<p>因为，程序在内存中的移动，意味着它的<strong>物理位置发生了变化</strong>，这时必须对程序和数据的地址(是绝对地址)进行修改后方能运行。然而，实际情况是，在运行过程中它在内存中的位置可能经常要改变，此时就应采用动态运行时装入的方式。</p>
</li>
</ol>
<h3 id="5-2-2-程序的链接">5.2.2 程序的链接</h3>
<p>根据链接时间的不同，可把链接分成如下三种：<br>
　　(1) 静态链接。在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。</p>
<p>(2) 装入时动态链接。这是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。</p>
<p>(3) 运行时动态链接。这是指对某些目标模块的链接，是在程序执行中需要该(目标)模块时，才对它进行的链接。</p>
<h2 id="5-3-连续分配方式">5.3 连续分配方式</h2>
<h3 id="5-3-1-单一连续分配">5.3.1 单一连续分配</h3>
<p>这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209172315362.png" alt="image-20231209172315362"></p>
<h3 id="5-3-2-固定分区分配">5.3.2 固定分区分配</h3>
<ol>
<li>
<p>分区大小相等</p>
<p>所有的内存分区大小相等。其缺点是缺乏灵活性，即当程序太小时，会造成内存空间的浪费；当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。尽管如此，这种划分方式仍被用于利用一台计算机去控制多个相同对象的场合，因为这些对象所需的内存空间是大小相等的。例如，炉温群控系统，就是利用一台计算机去控制多台相同的冶炼炉。</p>
</li>
<li>
<p>分区大小不等</p>
<p>为了克服分区大小相等而缺乏灵活性的这个缺点，可把内存区划分成含有多个较小的分区、适量的中等分区及少量的大分区。这样，便可根据程序的大小为之分配适当的分区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209172720774.png" alt="image-20231209172720774"></p>
</li>
</ol>
<h3 id="5-3-3-动态分区分配（重点）">5.3.3 动态分区分配（重点）</h3>
<p>动态分区分配是根据进程的实际需要，动态地为之分配内存空间。在实现可变分区分配时，将涉及到分区分配中所用的<strong>数据结构、分区分配算法和分区的分配与回收操作</strong>这样三个问题。</p>
<ol>
<li>
<p>分区分配中的数据结构</p>
<ul>
<li>
<p>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</p>
</li>
<li>
<p>空闲分区链：为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231209173124782.png" alt="image-20231209173124782"></p>
</li>
</ul>
</li>
<li>
<p>分区分配算法（重点）</p>
<ul>
<li>
<p>首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。空闲分区以地址递增的次序排序，每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个第一个空闲分区。</p>
<p>优点：倾向于优先利用内存中低址部分的空闲分区，从而<strong>保留了高址部分的大空闲区</strong>。这给为<strong>以后到达的大作业分配大的内存空间创造了条件</strong>。</p>
<p>缺点：低址部分不断被划分，会<strong>留下许多难以利用的、很小的空闲分区</strong>，而每次查找又都是从低址部分开始，这无疑会<strong>增加查找可用空闲分区时的开销</strong>。</p>
</li>
<li>
<p>循环首次适应算法：由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是<strong>从上次找到的空闲分区的下一个空闲分区开始查找</strong>，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。该算法能使内存中的<strong>空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。</strong></p>
</li>
<li>
<p>最佳适应算法：所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。<strong>空闲分区按照容量递增次序连接</strong>。每次分配内存时<strong>顺序查找</strong>空闲房分区链（或空闲分区表），找到大小能满足的第一个空闲分区。</p>
<p>缺点：每次都选最小的分区进行分配，会留下越来越大，很小的，难以利用的内存块。因此这种方法会产生很多外部碎片。</p>
</li>
<li>
<p>最坏适应算法：最坏适应分配算法要扫描整个空闲分区表或链表，<strong>总是挑选一个最大的空闲区分割给作业使用</strong>，其<strong>优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高</strong>。该算法要求将所有的空闲分区按其容量以<strong>从大到小</strong>的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。但是该算法的<strong>缺点也是明显的，它会使存储器中缺乏大的空闲分区。</strong></p>
</li>
<li>
<p>快速适应算法：又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，如2 KB、4 KB、8 KB等，对于其它大小的分区，如7 KB这样的空闲区，既可以放在8 KB的链表中，也可以放在一个特殊的空闲区链表中。</p>
<p>优点：<strong>查找效率高，<strong>仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也</strong>不会产生内存碎片。</strong></p>
<p>缺点：分区归还主存时算法复杂，系统开销较大。以空间换时间，会造成空间浪费。</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-4-对换">5.4 对换</h2>
<p>在多道程序的环境下，一反面，在内存中的某些进程由于某事件尚未发生而<strong>被阻塞</strong>运行，但是它却<strong>占用大量的内存空间</strong>，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况。显然这对系统资源是一种严重的浪费，且使得系统吞吐量下降。为了解决这一问题，在系统中又增设了对换(也称交换)设施。所谓“对换”，<strong>是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施</strong>。</p>
<p>对换分为<strong>整体对换（进程对换）<strong>和</strong>部分对换（页面对换或分段对换）</strong>：</p>
<ul>
<li>对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。被广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。</li>
<li>对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。对换方法是实现后面要讲到的请求分页和请求分段式存储管理的基础，其目的是为了支持<strong>虚拟存储系统。</strong></li>
</ul>
<p>为了实现进程对换，系统必须能实现三方面的功能：对换空间的管理、进程的换出，以及进程的换入。</p>
<ul>
<li>对换空间的管理：外存分为<strong>文件区和对换区</strong>。前者用于存放文件，后者用于存放从内存换出的进程。由于通常的文件都是较<strong>长久地驻留在外存</strong>上，故对文件区管理的主要目标，<strong>是提高文件存储空间的利用率，<strong>为此，对文件区采取</strong>离散分配</strong>方式。进程在对换区中驻留的时间是<strong>短暂的，<strong>对换操作又较</strong>频繁</strong>，故对对换空间管理的主要目标，是提高<strong>进程换入和换出的速度</strong>。为此，采取的是<strong>连续分配方式，较少考虑外存中的碎片问题</strong>。</li>
<li>进程的换出：系统首先选择<strong>处于阻塞状态且优先级最低</strong>的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。</li>
<li>进程的换入：系统应定时地查看所有进程的状态，从中<strong>找出“就绪”状态但已换出的进程</strong>，将其中**换出时间最久(换出到磁盘上)**的进程作为换入进程，将之换入</li>
</ul>
<h2 id="5-5-分页存储管理方式（重点）">5.5 分页存储管理方式（重点）</h2>
<h3 id="5-5-1-什么是分页存储">5.5.1 什么是分页存储</h3>
<p>将内存空间分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个<strong>页框（页框=页帧=内存块=物理块=物理页面）</strong>，每个页框有一个编号。即**“页框号”（页框号=页帧号=内存块号=物理块号=物理页号），页框号从0开始。**</p>
<p>将进程 的<strong>逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个**“页”或“页面”<strong>。每个页面也有一个编号。即“<strong>页号”</strong>，页号也是</strong>从0开始。**</p>
<p>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong> 与内存的<strong>页框</strong>有<strong>一一对应的关系</strong>。</p>
<p>各个页面不必连续存放，可以放到不相邻的各个页框中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210132226152.png" alt="image-20231210132226152"></p>
<h3 id="5-5-2-页表">5.5.2 页表</h3>
<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。页表 通常存在 PCB（进程控制块）中。</p>
<ul>
<li>一个进程对应一张页表</li>
<li>进程的每个页面对应一个页表项</li>
<li>每个<strong>页表项由“页号”和“块号”组成</strong></li>
<li>页表记录进程页面和实际存放的内存块之间的映射关系</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210132808701.png" alt="image-20231210132808701"></p>
<p>每个页表项占多少字节？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210133816416.png" alt="image-20231210133816416"></p>
<p>而页号是不占用字节的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210134032957.png" alt="image-20231210134032957"></p>
<p>如何实现地址的转换？如果要访问逻辑地址A，则</p>
<ol>
<li>确定逻辑地址A对应的页号P</li>
<li>找到P号页面在内存中的起始地址（需要查页表)</li>
<li>确定逻辑地址A的页内偏移量w</li>
</ol>
<p>逻辑地址A对应的物理地址=P号页面在内存中的起始地址+页内偏移量W</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210134905457.png" alt="image-20231210134905457"></p>
<p>页号=逻辑地址/页面长度（取除法的整数部分）</p>
<p>页内偏移量=逻辑地址%页面长度（取除法的余数部分）</p>
<h3 id="5-5-3-逻辑地址结构">5.5.3 逻辑地址结构</h3>
<p>分页存储管理的逻辑地址结构如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210135849585.png" alt="image-20231210135849585"></p>
<h3 id="5-5-4-基本地址变换机构（重点）">5.5.4 基本地址变换机构（重点）</h3>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址</p>
<p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的起始地址额页表长度存放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210140914039.png" alt="image-20231210140914039"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210141814918.png" alt="image-20231210141814918"></p>
<h3 id="5-5-5-具有快表的地址变换机构">5.5.5 具有快表的地址变换机构</h3>
<p>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“快表”。地址变换过程是：在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。如在块表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中，亦即，重新修改快表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210142801835.png" alt="image-20231210142801835"></p>
<h2 id="5-6-分段存储管理方式">5.6 分段存储管理方式</h2>
<h3 id="5-6-1-分段存储管理方式的引入">5.6.1 分段存储管理方式的引入</h3>
<p>好处：</p>
<ol>
<li>方便编程</li>
<li>信息共享</li>
<li>信息保护</li>
<li>适应段的动态增长需求</li>
<li>动态连接</li>
</ol>
<h3 id="5-6-2-分段系统的基本原理">5.6.2 分段系统的基本原理</h3>
<p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等</p>
<p>分段地址中的地址具有如下结构： 2^16 ×2^16</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210145203388.png" alt="image-20231210145203388"></p>
<p>在该地址结构中，允许一个作业最长有 64 K个段，每个段的最大长度为64 KB。</p>
<h3 id="5-6-3-段表">5.6.3 段表</h3>
<p>在分段式存储管理系统中，则是为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。为使程序能正常运行，亦即，能从物理内存中找出每个逻辑段所对应的位置，应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址(又称为“基址”)和段的长度</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210145510794.png" alt="image-20231210145510794"></p>
<h3 id="5-6-4-地址变换机构">5.6.4 地址变换机构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210145554408.png" alt="image-20231210145554408"></p>
<h2 id="5-7-分段和分页的主要区别（重点）">5.7 分段和分页的主要区别（重点）</h2>
<p>两者都采用离散分配方式，且都要通过地址映射机构来实现地址变换。但在概念上两者完全不同，主要表现在下述三个方面。</p>
<ol>
<li><strong>页是信息的物理单位</strong>，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说分页仅仅是系统管理的需要而不是用户的需要。**段则是信息的逻辑单位，**分段得到目的是为了更好的满足用户的需求。</li>
<li><strong>页的大小固定且由系统来决定，而段的长度却不固定，决定于用户编写的程序。</strong></li>
<li>分页的<strong>作业地址空间是一维</strong>的。<strong>分段的作业地址空间时二维的</strong>，既需要给出段名，有需要给出段内地址。</li>
</ol>
<h1>六、虚拟存储器</h1>
<h2 id="6-1-虚拟存储器的定义和特征（重要）">6.1 虚拟存储器的定义和特征（重要）</h2>
<p><strong>定义：</strong></p>
<ul>
<li>基于局部性原理，在程序装入时，可以将程序中<strong>很快会用到的部分装入内存，暂时用不到的部分留在外存</strong>，就可以让程序开始执行。</li>
<li>在程序执行过程中，当所访问的<strong>信息不在内存时</strong>，由操作系统负责<strong>将所需信息从外存调入内存</strong>，然后继续执行程序</li>
<li>若内存空间不够，由操作系统<strong>负责将内存中暂时用不到的信息换出到内存</strong></li>
</ul>
<p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p>
<p><strong>虚拟内存有以下三个特征：</strong></p>
<ol>
<li>**多次性：**无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li>
<li>**对换性：**在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入，换出。</li>
<li>**虚拟性：**从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量。</li>
</ol>
<h2 id="6-2-请求分页存储管理方式">6.2 请求分页存储管理方式</h2>
<p>请求分页存储管理与基本分页存储管理的主要区别：</p>
<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<strong>操作系统要提供请求调页功能，将缺失页面从外存调入内存。</strong></p>
<p>若内存空间不足，由操作系统负责将内存中暂时用不到的信息换出内存。<strong>操作系统要提供页面置换功能，将暂时用不到的页面换出内存。</strong></p>
<p>1.页表机制：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210161136236.png" alt="image-20231210161136236"></p>
<p>2.缺页中断机构</p>
<p>在<strong>请求分页系统</strong>中，每当所要访问的<strong>页面不在内存</strong>时，便产生一<strong>缺页中断</strong>，请求OS将所缺之页调入内存。缺页中断作为中断，它们同样需要经历诸如保护<strong>CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境</strong>等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的区别，主要表现在下面两个方面：</p>
<ul>
<li>在指令执行期间产生和处理中断信号</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
<p>3.地址变换机构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210163249328.png" alt="image-20231210163249328"></p>
<h2 id="6-3-页面置换算法（重要）">6.3 页面置换算法（重要）</h2>
<h3 id="6-3-1-最佳置换算法（OPT）">6.3.1 最佳置换算法（OPT）</h3>
<p>最佳置换算法：每次选择<strong>淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210165114498.png" alt="image-20231210165114498"></p>
<p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的。</strong></p>
<h3 id="6-3-2-先进先出置换算法（FIFO）">6.3.2 先进先出置换算法（FIFO）</h3>
<p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。</p>
<p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择对头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210165753510.png" alt="image-20231210165753510"></p>
<p>Balady异常——当为进程分配的物理块增大时，缺页次数不减反增现象。</p>
<p>缺点：**只有FIFO算法会产生Balady异常。**另外，FIFO虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能是最经常被访问因此，<strong>算法性能差。</strong></p>
<h3 id="6-3-3-最近最久未使用置换算法（LRU）">6.3.3 最近最久未使用置换算法（LRU）</h3>
<p>最近最久未使用置换算法（LRU）：每次<strong>淘汰的页面是最近最久未使用的页面</strong>。</p>
<p>实现方法：赋予每个页面对应的页表项中用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210171430770.png" alt="image-20231210171430770"></p>
<p>在手动做题时，若需要淘汰页面，可以<strong>逆向检查此时在内存中几个页面。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</strong></p>
<h3 id="6-3-4-时钟置换算法（CLOCK）">6.3.4 时钟置换算法（CLOCK）</h3>
<p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但性能差；最近最久未使用置换算法性能好，，是最接近最佳置换算法，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法。</p>
<ol>
<li>
<p>简单的Clock置换算法</p>
<p>当采用简单Clock算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置1。置换算法在选择一页淘汰时，只需检查页的访问位。如果是0，就选择该页换出；若为1，则重新将它置0，暂不换出，而给该页第二次驻留内存的机会，再按照FIFO算法检查下一个页面。当检查到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首去检查第一个页面。</p>
</li>
<li>
<p>改进型Clock置换算法</p>
<p>在将一个页面换出时，如果该页已被修改过，便须将该页重新写回到磁盘上；但如果该页未被修改过，则不必将它拷回磁盘。在改进型Clock算法中，除须考虑页面的使用情况外，还须再增加一个因素，即置换代价，这样，选择页面换出时，既要是未使用过的页面，又要是未被修改过的页面。把同时满足这两个条件的页面作为首选淘汰的页面。由访问位A和修改位M可以组合成下面四种类型的页面：</p>
<p>​        1类(A=0，M=0)：表示该页最近既未被访问，又未被修改，是最佳淘汰页。<br>
　　2类(A=0，M=1)：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。<br>
　　3类(A=1，M=0)：表示该页最近已被访问，但未被修改，该页有可能再被访问。<br>
　　4类(A=1，M=1)：表示该页最近已被访问且被修改，该页可能再被访问。</p>
<p>(1) 从指针所指示的当前位置开始，扫描循环队列，寻找A=0且M=0的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。</p>
<p>(2) 如果第一步失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找A=0且M=1的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。<br>
(3) 如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。然后重复第一步，如果仍失败，必要时再重复第二步，此时就一定能找到被淘汰的页。</p>
</li>
</ol>
<h3 id="6-3-5-各算法总结">6.3.5 各算法总结</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231210175159267.png" alt="image-20231210175159267"></p>
<h1>七、输入输出系统</h1>
<h2 id="7-1-I-O系统的层次结构和模型">7.1 I/O系统的层次结构和模型</h2>
<p>通常把I/O软件组织分成四个层次，如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211193939605.png" alt="image-20231211193939605"></p>
<ol>
<li>用户层软件：实现与用户交互的接口，用户可之后可直接调用用户层提供的、与I/O操作有关的库函数，对设备进行操作。</li>
<li>设备独立性软件：负责实现与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据提供必要的存储空间。</li>
<li>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。</li>
<li>中断处理程序：用户保存被中断进程的CPU环境，转入相应的中端程序进行处理，产后护理完会后再恢复被中断进程的现场后返回到被中断进程。</li>
</ol>
<h2 id="7-2-I-O设备和设备控制器">7.2 I/O设备和设备控制器</h2>
<h3 id="7-2-1-I-O设备的分类">7.2.1 I/O设备的分类</h3>
<p>I/O设备的类型繁多，从OS观点看，其重要的性能指标有: 设备使用特性、数据传输速率、数据的传输单位、设备共享属性等。因而可从不同角度对它们进行分类。</p>
<ul>
<li>按使用特性分：1、存储设备  2、输入/输出设备</li>
<li>按传输速率分：1、低速设备  2、中速设备  3、高速设备</li>
<li>按信息交换分：1、块设备  2、字符设备</li>
<li>按设备的共享属性分：1、独占设备  2、共享设备 3、虚拟设备</li>
</ul>
<h3 id="7-2-2-设备与控制器之间的接口">7.2.2 设备与控制器之间的接口</h3>
<p>设备并不是直接CPU进行通信，而是与设备控制器通信，因此，在I/O设备中应含有与设备控制器间的接口，因此，在I/O设备中应含有与设备控制器间的接口，在接口中有三种类型的信号，各对应一条信号线。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211195409112.png" alt="image-20231211195409112"></p>
<ol>
<li>数据型号线：用于设备与设备控制器之间传送数据信号</li>
<li>控制信号线：作为由设备控制器向I/O设备发送控制信号时的通路</li>
<li>状态信号线：用于传送指示设备与当前状态的信号。</li>
</ol>
<h3 id="7-2-3-设备控制器">7.2.3 设备控制器</h3>
<p>基本功能：</p>
<ul>
<li>接收和识别命令</li>
<li>数据交换</li>
<li>标识和报告设备的状态</li>
<li>地址识别</li>
<li>数据缓冲</li>
<li>差错控制</li>
</ul>
<h2 id="7-3-中断机构和中断处理程序">7.3 中断机构和中断处理程序</h2>
<h3 id="7-3-1-中断简介">7.3.1 中断简介</h3>
<ol>
<li>
<p>中断和陷入</p>
<p>中断：CPU对I/O发出的中断信号的一种响应</p>
<p>陷入：CPU内部事件引发的（上溢或下溢）</p>
</li>
<li>
<p>中断向量表和中断优先级</p>
<p>中断向量表：保存中断处理程序的入口地址</p>
<p>中断优先级：键盘&lt;打印机&lt;磁盘</p>
</li>
<li>
<p>多中断源的处理方式　　	<br>
屏蔽中断、嵌套中断</p>
</li>
</ol>
<h3 id="7-3-2-中断处理">7.3.2 中断处理</h3>
<p>对于不同的设备，有不同的中断处理程序，该程序首先从设备控制器读出设备状态，以判别本次<strong>中断是正常完成中断，还是异常结束中断</strong>。若是前者，<strong>中断程序便进行结束处理</strong>；若还有命令，可再向控制器发送新的命令，进行新一轮的数据传送。若是异常结束中断，则<strong>根据发生异常的原因做相应的处理。</strong></p>
<h2 id="7-4-I-O控制方式">7.4 I/O控制方式</h2>
<h3 id="7-4-1-程序I-O方式">7.4.1 程序I/O方式</h3>
<p>也称忙等待方式，即在处理机向控制器发出一条I/O指令启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy置为1，然后便不断地循环测试busy。当busy=1时，表示输入机尚未输完一个字(符)，处理机应继续对该标志进行测试，直至busy=0，表明输入机已将输入数据送入控制器的数据寄存器中。于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字(符)的I/O。接着再去启动读下一个数据，并置busy=1。</p>
<h3 id="7-4-2-中断驱动I-O控制方式">7.4.2 中断驱动I/O控制方式</h3>
<p>引入中断机构后，当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务。设备控制器于是按照该命令的要求去控制指定I/O设备。此时，CPU与I/O设备并行操作。例如，在输入时，当设备控制器收到CPU发来的读命令后，便去控制相应的输入设备读数据。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一中断信号，由CPU检查输入过程中是否出错，若无错，便向控制器发送取走数据的信号，然后再通过控制器及数据线将数据写入内存指定单元中。</p>
<h3 id="7-4-3-直接存储器访问-DMA-I-O控制方式">7.4.3 直接存储器访问(DMA)I/O控制方式</h3>
<p>虽然中断驱动I/O比程序I/O方式更有效，但须注意，它仍是以字(节)为单位进行I/O的，每当完成一个字(节)的I/O时，控制器便要向CPU请求一次中断。换言之，采用中断驱动I/O方式时的CPU是以字(节)为单位进行干预的。如果将这种方式用于块设备的I/O，显然是极其低效的。例如，为了从磁盘中读出1 KB的数据块，需要中断CPU 1K次。为了进一步减少CPU对I/O的干预而引入了直接存储器访问方式。</p>
<p>该方式的特点是：</p>
<p>(1) 数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；</p>
<p>(2) 所传送的数据是从设备直接送入内存的，或者相反；<br>
(3) 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。<br>
　　可见，DMA方式较之中断驱动方式，又是成百倍地减少了CPU对I/O的干预，进一步提高了CPU与I/O设备的并行操作程度。</p>
<h3 id="7-4-4-I-O通道控制方式">7.4.4  I/O通道控制方式</h3>
<p>虽然DMA方式比起中断方式来已经显著地减少了CPU的干预，即已由以字(节)为单位的干预减少到以数据块为单位的干预，但CPU每发出一条I/O指令，也只能去读(或写)一个连续的数据块。而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则须由CPU分别发出多条I/O指令及进行多次中断处理才能完成。</p>
<p>I/O通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读(或写)为单位的干预减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。同时，又可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。例如，当CPU要完成一组相关的读(或写)操作及有关控制时，只需向I/O通道发送一条I/O指令，以给出其所要执行的通道程序的首址和要访问的I/O设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I/O任务。</p>
<h3 id="四种控制方式的总结与比较">四种控制方式的总结与比较</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211202002485.png" alt="image-20231211202002485"></p>
<h2 id="7-5-设备分配">7.5 设备分配</h2>
<h3 id="7-5-1-设备分配中数据结构">7.5.1 设备分配中数据结构</h3>
<ol>
<li>设备控制表（DCT）：系统为每一个设备都配置了一张设备控制表，用于记录本设备的情况。</li>
<li>控制器控制表（COCT)：用于记录本控制器情况的控制器控制表</li>
<li>通道控制表（CHCT）：每个通道都配有一张通道控制表</li>
<li>系统设备表（SDT）：这是系统范围的数据结构，其中记录了系统中全部设备的情况。每个设备占一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等项</li>
</ol>
<h3 id="7-5-2-分配设备">7.5.2 分配设备</h3>
<ol>
<li>首先根据I/O请求中的物理设备名，查找系统设备表(SDT)，从中找出该设备的DCT，再根据DCT中的设备状态字段，可知该设备是否正忙。若忙，便将请求I/O进程的PCB挂在设备队列上；否则，便按照一定的算法来计算本次设备分配的安全性。如果不会导致系统进入不安全状态，便将设备分配给请求进程；否则，仍将其PCB插入设备等待队列。</li>
<li>在系统把设备分配给请求I/O的进程后，再到其DCT中找出与该设备连接的控制器的COCT，从COCT的状态字段中可知该控制器是否忙碌。若忙，便将请求I/O进程的PCB挂在该控制器的等待队列上；否则，便将该控制器分配给进程。</li>
<li>在该COCT中又可找到与该控制器连接的通道的CHCT，再根据CHCT内的状态信息，可知该通道是否忙碌。若忙，便将请求I/O的进程挂在该通道的等待队列上；否则，将该通道分配给进程。只有在设备、 控制器和通道三者都分配成功时，这次的设备分配才算成功。然后，便可启动该I/O设备进行数据传送。</li>
</ol>
<h2 id="7-6-磁盘调度算法">7.6 磁盘调度算法</h2>
<h3 id="7-6-1-先来先服务（FCFS）">7.6.1 先来先服务（FCFS）</h3>
<p>根据进程请求访问磁盘的先后次序进行调度。此算法的<strong>优点是公平、简单</strong>，且每个进程的请求都能依次地得到处理，不会出现某一进程的请求长期得不到满足的情况。但此算法由于<strong>未对寻道进行优化，致使平均寻道时间可能较长</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211203620186.png" alt="image-20231211203620186"></p>
<h3 id="7-6-2-最短寻道时间优先-SSTF）">7.6.2 最短寻道时间优先(SSTF）</h3>
<p>其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211203717702.png" alt="image-20231211203717702"></p>
<h3 id="7-6-3-基于扫描的磁盘调度算法">7.6.3 基于扫描的磁盘调度算法</h3>
<p>SSTF算法虽然能获得较好的寻道性能，但却可能导致某个进程发生“饥饿”(Starvation)现象。因为只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I/O请求必然优先满足。对SSTF算法略加修改后所形成的SCAN算法，即可防止老进程出现“饥饿”现象。</p>
<ol>
<li>
<p>SCAN算法</p>
<p>该算法不仅考虑到欲访问的磁道与当前磁道间的距离，更<strong>优先考虑的是磁头当前的移动</strong>方向。例如，当磁头正<strong>在自里向外移动</strong>时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直至<strong>再无更外的磁道</strong>需要访问时，才将磁臂换向为<strong>自外向里</strong>移动。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211204028470.png" alt="image-20231211204028470"></p>
</li>
<li>
<p>循环扫描(CSCAN)算法</p>
<p>SCAN算法既能获得较好的寻道性能，又能防止“饥饿”现象，故被广泛用于大、中、小型机器和网络中的磁盘调度。但SCAN也存在这样的问题：当磁头刚从里向外移动而越过了某一磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。</p>
<p>为了减少这种延迟，CSCAN算法规定<strong>磁头单向移动，<strong>例如，<strong>只是自里向外移动</strong>，当磁头</strong>移到最外</strong>的磁道并访问后，磁头<strong>立即返回到最里的欲访问的磁道</strong>，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20231211204157492.png" alt="image-20231211204157492"></p>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小吴顶呱呱</div><div class="post-copyright__author_desc">好好生活 好好吃饭 别卷了</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/')">操作系统知识点总结</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/weixin.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/weixin.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zhifubao.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/zhifubao.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=操作系统知识点总结&amp;url=https://xiaofusu.github.io/2023/12/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/&amp;pic=/img/aust3.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiaofusu.github.io" target="_blank">小扶苏</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>操作系统<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://redwerk.com/wp-content/uploads/2019/11/Redis.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/01/jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://colaninfotech.com/wp-content/uploads/2021/01/jvm-blog2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jvm性能调优</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/16/spring-boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nextre.it/wp-content/uploads/2020/09/spring-boot-scaled-1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">spring boot自动配置原理</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><h3>莫愁前路无知己</h3></div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><h3>天下谁人不识君</h3></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小吴顶呱呱</h1><div class="author-info__desc">好好生活 好好吃饭 别卷了</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaofusu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/651626088?spm_id_from=333.1007.0.0" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一、操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 操作系统的定义与目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 操作系统的基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 操作系统的特征（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">1.4操作系统的中断处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">1.5操作系统的发展与分类（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">1.6操作系统的主要功能（重点）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二、进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">2.2进程的五个特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">2.3进程的基本状态与转换（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 进程的三种基本状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E4%BA%94%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 五状态转换模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 挂起操作和进程状态的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 进程控制块PCB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-PCB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 PCB的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-PCB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 PCB的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-PCB%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 PCB中的信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 线程与进程的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">三、处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 处理机调度的层次和调度算法的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 作业与作业调度（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88FCFS"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 先来先服务调度算法（FCFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-SJF"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 短作业优先调度算法(SJF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-HRRN"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 高优先权优先调度算法(HRRN)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-RR"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 基于时间片的轮转调度算法(RR)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5 多级反馈队列调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 实时调度（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 最早截止时间优先算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 最低松弛度优先算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 死锁概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 银行家算法（重点）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">四、进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 进程同步概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 信号量机制（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 整型信号量（了解即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 记录型信号量（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 AND型信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 信号量的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 经典进程的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3 读者-写者问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">五、存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">5.1存储器的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 程序的装入和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 三种装入方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 程序的链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 连续分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3 动态分区分配（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AF%B9%E6%8D%A2"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 对换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 分页存储管理方式（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 什么是分页存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E9%A1%B5%E8%A1%A8"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2 页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3 逻辑地址结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-4-%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.5.4.</span> <span class="toc-text">5.5.4 基本地址变换机构（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-5-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">5.5.5.</span> <span class="toc-text">5.5.5 具有快表的地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 分段存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.6.1 分段存储管理方式的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.6.2 分段系统的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-%E6%AE%B5%E8%A1%A8"><span class="toc-number">5.6.3.</span> <span class="toc-text">5.6.3 段表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">5.6.4.</span> <span class="toc-text">5.6.4 地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 分段和分页的主要区别（重点）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">六、虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 虚拟存储器的定义和特征（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 请求分页存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 页面置换算法（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1 最佳置换算法（OPT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2 先进先出置换算法（FIFO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3 最近最久未使用置换算法（LRU）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4 时钟置换算法（CLOCK）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-5-%E5%90%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.5.</span> <span class="toc-text">6.3.5 各算法总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">七、输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 I&#x2F;O系统的层次结构和模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-I-O%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 I&#x2F;O设备和设备控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1 I&#x2F;O设备的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2 设备与控制器之间的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3 设备控制器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 中断机构和中断处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E4%B8%AD%E6%96%AD%E7%AE%80%E4%BB%8B"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1 中断简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2 中断处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E7%A8%8B%E5%BA%8FI-O%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.4.1 程序I&#x2F;O方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.4.2 中断驱动I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE-DMA-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.3.</span> <span class="toc-text">7.4.3 直接存储器访问(DMA)I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4-I-O%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.4.</span> <span class="toc-text">7.4.4  I&#x2F;O通道控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%AF%94%E8%BE%83"><span class="toc-number">7.4.5.</span> <span class="toc-text">四种控制方式的总结与比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 设备分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.5.1 设备分配中数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.5.2 分配设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89"><span class="toc-number">7.6.1.</span> <span class="toc-text">7.6.1 先来先服务（FCFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-SSTF%EF%BC%89"><span class="toc-number">7.6.2.</span> <span class="toc-text">7.6.2 最短寻道时间优先(SSTF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-%E5%9F%BA%E4%BA%8E%E6%89%AB%E6%8F%8F%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">7.6.3.</span> <span class="toc-text">7.6.3 基于扫描的磁盘调度算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/04/redis%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="redis：分布式锁"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://redwerk.com/wp-content/uploads/2019/11/Redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis：分布式锁"/></a><div class="content"><a class="title" href="/2024/03/04/redis%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="redis：分布式锁">redis：分布式锁</a><time datetime="2024-03-04T11:34:35.000Z" title="发表于 2024-03-04 19:34:35">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/20/redis%EF%BC%9A%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" title="redis：缓存雪崩"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://redwerk.com/wp-content/uploads/2019/11/Redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis：缓存雪崩"/></a><div class="content"><a class="title" href="/2024/02/20/redis%EF%BC%9A%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" title="redis：缓存雪崩">redis：缓存雪崩</a><time datetime="2024-02-20T14:35:33.000Z" title="发表于 2024-02-20 22:35:33">2024-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/07/redis%EF%BC%9A%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/" title="redis：缓存击穿"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://redwerk.com/wp-content/uploads/2019/11/Redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis：缓存击穿"/></a><div class="content"><a class="title" href="/2024/02/07/redis%EF%BC%9A%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/" title="redis：缓存击穿">redis：缓存击穿</a><time datetime="2024-02-07T11:55:13.000Z" title="发表于 2024-02-07 19:55:13">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/07/redis%EF%BC%9A%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" title="redis：缓存穿透"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://redwerk.com/wp-content/uploads/2019/11/Redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis：缓存穿透"/></a><div class="content"><a class="title" href="/2024/02/07/redis%EF%BC%9A%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" title="redis：缓存穿透">redis：缓存穿透</a><time datetime="2024-02-07T09:57:03.000Z" title="发表于 2024-02-07 17:57:03">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/03/JUC%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" title="JUC（四）：线程基本方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://wzy-sky-takeaway.oss-cn-hangzhou.aliyuncs.com/43IJI2J%7DCJQEB%405%25%29YUYH6T.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC（四）：线程基本方法"/></a><div class="content"><a class="title" href="/2024/02/03/JUC%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" title="JUC（四）：线程基本方法">JUC（四）：线程基本方法</a><time datetime="2024-02-03T08:29:27.000Z" title="发表于 2024-02-03 16:29:27">2024-02-03</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="/3118732544@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/xiaofusu" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/651626088?spm_id_from=333.1007.0.0" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="小吴顶呱呱" target="_blank">小吴顶呱呱</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://image.anheyu.com" title="图床">图床</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaofusu" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://space.bilibili.com/651626088?spm_id_from=333.1007.0.0" title="哔站"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="哔站"/><span class="back-menu-item-text">哔站</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaofusu/My_Takeaway" title="小吴外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="小吴外卖"/><span class="back-menu-item-text">小吴外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://gitee.com/wu-zhiyifs/regiee" title="瑞吉外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="瑞吉外卖"/><span class="back-menu-item-text">瑞吉外卖</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2312165875&amp;server=netease/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gateway/" style="font-size: 0.88rem;">Gateway<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 0.88rem;">HashMap<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/OpenFeign/" style="font-size: 0.88rem;">OpenFeign<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>18</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>8</sup></a><a href="/tags/maven/" style="font-size: 0.88rem;">maven<sup>1</sup></a><a href="/tags/nacos/" style="font-size: 0.88rem;">nacos<sup>1</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>4</sup></a><a href="/tags/springboot/" style="font-size: 0.88rem;">springboot<sup>3</sup></a><a href="/tags/springcloud/" style="font-size: 0.88rem;">springcloud<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 0.88rem;">八股<sup>8</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>4</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="2312165875" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/%E5%89%8D%E7%AB%AF" title="前端">前端</a><a class="tag-list" href="/tags/java" title="java">java</a><a class="tag-list" href="/tags/%E5%85%AB%E8%82%A1" title="八股">八股</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=2312165875&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("11/14/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.9",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小吴顶呱呱 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("11/14/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.56.5/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://xiaofusu-twikoo.hf.space',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://xiaofusu-twikoo.hf.space',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://xiaofusu-twikoo.hf.space',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>